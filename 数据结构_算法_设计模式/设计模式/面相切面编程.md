面相切面编程（AOP）的主要功能是业务分离，其中比较常见的应用场景是将业务代码和非业务代码进行分离。比如日志记录、数据上报、性能分析等功能就适合用面向切面编程来实现。

假如我们需要在很多功能中加上日志记录和数据上报，当然，首先想到的是将日志记录和数据上报封装成单独的方法，在相应的地方进行调用，如：
```js
function addUser() {
    // ... 这里是添加用户的业务代码

    // 进行日志记录和数据上报
    logger();
    report();
}
```

如果很多地方都要同时使用者两个功能那么我们可能需要封装成一个方法：
```js
function addUser() {
    // ... 业务代码

    // 进行日志记录和数据上报
    loggerAndReport();
}
```
但是如果要在业务代码之前加上日志记录功能呢？就只能这样了
```js
function addUser() {
    logger();

    // ... 业务代码

    // 进行日志记录和数据上报
    loggerAndReport();
}
```

现在，假如我们已经在很多地方加上了前置 logger，然后现在不需要了，那么我们就需要在所有的地方删除前置 logger，这也说明了现有的封装并不是很好。

面相切面编程这时就能显现威力了。
比较老的方法是：
```js
// 这里有点绕，实际上是在每次调用 before 或 after 后会返回一个新函数，
// 当继续调用 before 或 after 时， _self 就是指向的之前链式调用所生成的那个新函数了，而不是最初开始调用的那个函数。
Function.prototype.before=function(func){
    var _self = this;
    return function() {
        if (func.apply(this,arguments) == false) {
            return false;
        }
        return _self.apply(this,arguments);
    }
}
Function.prototype.after=function(func){
    var _self=this;
    return function() {
        var ret = _self.apply(this,arguments);
        if (ret === false) {
            return false;
        }
        func.apply(this,arguments);
        return ret;
    }
}

var addUser = function() {
    // ...
};

var logger = function() {
    // ...
};

var report = function() {
    // ...
};

const fn = addUser.before(logger).after(logger).after(report);
fn();
```

以上是给一个固定的函数动态添加之前和之后的功能。如果我们之前和之后的功能固定，动态执行一个自定义函数，那么就可以使用高阶函数：
```js
function loggerAndReport(fn) {
    return function() {
        logger();
        fn();
        logger();
        report();
    }
}
function addUser() {
    // ...
}
const fn = loggerAndReport(addUser);
fn();
```

所以通常高阶函数和装饰器是面向切面编程的一种较好的实践。