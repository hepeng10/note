
## 最小生成树
<img src="./img/tu23.jpg" width=600 />
这是一个带权值的图，即网结构。我们在讲图的定义和术语时，曾经提到过，一个连通图的生成树是一个极小的连通子图，它含有图中全部的顶点，但只有足以构成一棵树的n-1条边。

<img src="./img/tu24.jpg" width=700 />
以上三种方案都是这个网的生成树。
**那么我们把构造连通网的最小代价生成树称为最小生成树（Minimum Cost SpanningTree）。即最小生成树中所有边的权值之和在各种生成树中为最小值。**

###### 找连通网的最小生成树，经典的有两种算法，普里姆算法和克鲁斯卡尔算法。
### 普里姆（Prim）算法
<img src="./img/tu25.jpg" width=700 />
Prim 算法先将图构造为邻接矩阵，然后以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树的。
<img src="./img/tu26.jpg" width=700 />
假设$N=(V,\{E\})$是连通网，TE是N上最小生成树中边的集合。算法从$U={u_0}(u_0∈V)，TE=\{\}$开始。重复执行下述操作：在所有$u∈U,v∈V-U$的边$(u,v)∈E$中找一条代价最小的边$(u_0,v_0)$并入集合TE，同时$v_0$并入U，直至$U=V$为止。此时TE中必有n-1条边，则$T=(V,\{TE\})$为N的最小生成树。
由算法代码中的循环嵌套可得知此算法的时间复杂度为$O(n^2)$。

### 克鲁斯卡尔（Kruskal）算法
我们也可以直接就以边为目标去构建，因为权值是在边上，直接去找最小权值的边来构建生成树也是很自然的想法，只不过构建时要考虑是否会形成环路而已。此时我们就用到了图的存储结构中的边集数组结构。以下是edge边集数组结构的定义代码：
```
/* 对边集数组Edge结构的定义 */

typedef struct

{

    int begin;

    int end;

    int weight;

} Edge;
```
我们将上图的邻接矩阵通过程序转化为下图的边集数组，并且对它们按权值从小到大排序。
<img src="./img/tu27.jpg" width=700 />
###### 注意在无向图中，创建此结构时，每条边的 begin 值应该比 end 小，这样在后面查找是否形成环路的时候会更方便。

**查找过程如下：**
<img src="./img/tu28.jpg" width=700 />
<img src="./img/tu29.jpg" width=700 />
<img src="./img/tu30.jpg" width=700 />
<img src="./img/tu31.jpg" width=700 />
**通过遍历边集数据结构，从最短的边开始查找，找到边和顶点并记录；继续查找第二短的边和顶点并记录；以此类推；注意在找到一条边时需要查看其两个顶点是否都在已找到的顶点中，如果都在则需要判断这条边是否会形成环路，如果会形成环路则跳过此边继续查找；最终所有的边遍历完成并且没有环路，得到最小生成树。**

**查找过程详解：**
1. 这里有9个顶点则创建一个长度为9的数组[null,null,null,null,null,null,null,null,null]，数组的索引表示开始节点，值表示结束节点。这个数组是用于查找是否形成环路的重要结构。
2. 首先我们找到最短的边长7，顶点为4-7，那么我们就在数组中将下标为4的值改为7，表示顶点4入顶点7出。[null,null,null,null,7,null,null,null,null]
3. 然后找到边长8，顶点为2-8，得到顶点2入顶点8出。[null,null,8,null,7,null,null,null,null]
4. 继续找到边长10，得到：[1,null,8,null,7,null,null,null,null]
5. 继续找到边长11，发现边长11的顶点为0-5，而数组中顶点0已有值，那么我们就取其值1，将数组索引1的值改为5，得到：[1,5,8,null,7,null,null,null,null]。也表示从顶点1入可以从顶点5出。
6. 继续找到边长12，顶点为1-8，从索引1得到5，然后索引5改为8得到：[1,5,8,null,7,8,null,null,null]
7. 继续找到边长16，有两条，我们分别处理。1-6的，通过索引1得到5，通过索引5得到8，然后将索引8改为6得到：[1,5,8,null,7,8,null,null,6]。另一条3-7，得到：[1,5,8,7,7,8,null,null,6]
8. 继续找边长17，顶点为5-6，通过索引5得到8，索引8得到6，那么我们将索引6设置为6吗？当然不行，这样就会得到从顶点6入又从顶点6出，自己指向自己，这就形成环路了！所以，边长17这条线pass！
9. 继续找边长19，顶点为6和7，得到：[1,5,8,7,7,8,7,null,6]
10. 继续查找，就发现所有的线都会形成环路。最后，上面找到的顶点和线就是最终结果。
<img src="./img/tu32.jpg" width=700 />

假设$N=(V,\{E\})$是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图$T={V,\{\}}$，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。以此类推，直至T中所有顶点都在同一连通分量上为止。

此算法的时间由边数e决定，时间复杂度为$O(loge)$，而外面有一个for循环e次。所以克鲁斯卡尔算法的时间复杂度为$O(eloge)$。

对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大的优势；而普里姆算法对于稠密图，即边数非常多的情况会更好一些。