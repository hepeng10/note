# 概要
我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Traversing Graph）。

图的任一顶点都可能和其余的所有顶点相邻接，极有可能存在沿着某条路径搜索后，又回到原顶点，而有些顶点却还没有遍历到的情况。**因此我们需要在遍历过程中把访问过的顶点打上标记，以避免访问多次而不自知。**

对于图的遍历来说，如何避免因回路陷入死循环，就需要科学地设计遍历方案，通常有两种遍历次序方案：**它们是深度优先遍历和广度优先遍历。**

## 深度优先遍历
深度优先遍历（Depth_First_Search），也有称为深度优先搜索，简称为DFS。
<img src="./img/tu21.jpg" width=700 />
###### 遍历方式：从顶点 A 开始，递归遍历左子节点，被遍历的节点打上已遍历的标记；当遍历到最后没有左子节点时，遍历其它节点，看是否已遍历，若都已遍历则返回上一个节点查看它的其它节点；若其它节点中发现未被遍历的节点，则遍历此节点并继续递归遍历；然后按照此规则查找未访问的节点递归遍历，子节点都已访问则返回上一级，最后返回顶点 A，对顶点 A 的所有子节点进行递归和返回再回到顶点 A，发现顶点 A 的所有子节点都是已遍历状态，遍历完成。

深度优先遍历就是一棵树的前序遍历。它从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到。事实上，我们这里讲到的是连通图，对于非连通图，只需要对它的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。

## 广度优先遍历
广度优先遍历（Breadth_First_Search），又称为广度优先搜索，简称BFS。

如果说图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历了。
<img src="./img/tu22.jpg" width=700 />
###### 变形原则是顶点A放置在最上第一层，让与它有边的顶点B、F为第二层，再让与B和F有边的顶点C、I、G、E为第三层，再将这四个顶点有边的D、H放在第四层。

对比图的深度优先遍历与广度优先遍历算法，你会发现，它们在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同。可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。
但是遍历的目的是为了寻找到合适的点，而不需要全图遍历，那么使用哪种遍历方式就需要仔细斟酌了。性能差别可能会非常大。
比如我在做图谱的查询两点间最短路径的算法中，目的是找到一条最短的路径就结束，而不用找完所有的最短路径。一开始使用的是深度优先遍历，那么在找到目标节点的时候并不能保证就是最短路径，因此需要进行全图遍历。而后面该用广度优先遍历，一层一层的遍历，找到目标节点就能确定是最短路径了，因为再往下层肯定路径会更长，所以性能高很多。
