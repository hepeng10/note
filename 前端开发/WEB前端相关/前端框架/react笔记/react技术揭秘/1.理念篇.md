## CPU 的瓶颈
JS 可以操作 DOM，GUI渲染线程与JS线程是互斥的。所以JS 脚本执行和浏览器布局、绘制不能同时执行。所以当 JS 执行一个长时间的任务时就可能导致浏览器的渲染阻塞造成卡顿。
React 在浏览器每一帧的时间中，预留一些时间给 JS 线程（优先渲染线程），React利用这部分时间更新组件（预留的初始时间是 5ms）。当预留的时间不够用时，React将线程控制权交还给浏览器使其有时间渲染 UI，React则等待下一帧时间到来继续被中断的工作。
这样的操作被称为**时间切片**，时间切片的关键是：将同步的更新变为可中断的异步更新。

在 React 的底层架构中，**Scheduler（调度器）、Reconciler（协调器）和 Renderer（渲染器）** 是三个核心模块，共同协作以实现高效渲染和响应式交互。以下是它们的分工与作用：

#### **1. Scheduler（调度器）**
**核心作用**：**任务优先级管理**，将渲染任务拆解并分配到浏览器空闲时间执行，避免主线程阻塞。  
- **任务切片**：将长任务切割为 5ms 的时间片（可动态调整），通过 `MessageChannel` 或 `setTimeout` 模拟 `requestIdleCallback`，确保浏览器每帧有空闲时间处理用户输入和渲染。
- **优先级控制**：基于 Lane 模型管理任务优先级（如用户点击事件优先级高于数据加载），高优任务可抢占低优任务。
- **中断与恢复**：若时间片耗尽或高优任务到达，暂停当前任务，记录断点并交还主线程，后续恢复执行。

**底层机制**：  
```javascript
// 伪代码示例：调度循环
function workLoop() {
  while (当前任务存在 && 剩余时间足够) {
    处理单个Fiber节点();
  }
  if (未完成) 通过MessageChannel触发下一轮调度();
}
```

#### **2. Reconciler（协调器）**
**核心作用**：**计算组件树的变化**，生成虚拟 DOM 差异（副作用列表）。  
- **Fiber 架构**：将组件树拆解为可中断的 Fiber 节点链表，支持深度优先遍历的断点恢复。
- **Diff 算法**：对比新旧虚拟 DOM，标记节点增删改（如 `Placement`、`Update`、`Deletion`）。
- **双缓存机制**：维护两棵 Fiber 树（`current` 和 `workInProgress`），交替更新以避免渲染过程中的视觉不一致。当 workInProgress Fiber 树构建完成交给 Renderer 渲染在页面上后，应用根节点的 current 指针指向 workInProgress Fiber 树，此时 workInProgress Fiber 树就变为 current Fiber 树。每次状态更新都会产生新的 workInProgress Fiber 树，通过 current 与 workInProgress 的替换，完成DOM更新。
- **副作用收集**：构建副作用链表，记录需执行的 DOM 操作。

Reconciler会为变化的虚拟 DOM 打上代表增/删/更新的标记，类似这样：
```js
export const Placement = /*             */ 0b0000000000010;
export const Update = /*                */ 0b0000000000100;
export const PlacementAndUpdate = /*    */ 0b0000000000110;
export const Deletion = /*              */ 0b0000000001000;
```
这里使用二进制是为了优化性能，不同的位表示不同的功能，比如 PlacementAndUpdate 就是 Update 和 Placement 对应的位都是1，然后通过位运算快速找出对应的位是否为1。
0b0000000000100 & 0b0000000000110 表示有更新；0b0000000000010 & 0b0000000000110 表示有新增。
**关键流程**：  
```javascript
// 伪代码示例：协调阶段
function performUnitOfWork(fiber) {
  对比新旧props，标记变更;
  生成子Fiber节点;
  return 下一个待处理节点;
}
```

#### **3. Renderer（渲染器）**
**核心作用**：**将 Reconciler 的变更应用到真实界面**。  
- **平台适配**：针对不同环境（浏览器、Native、Canvas）实现具体渲染逻辑。例如，`ReactDOM` 负责 DOM 操作，`React Native` 处理原生组件。
- **同步提交**：在不可中断的 `commit` 阶段，批量执行副作用链表中的 DOM 更新，确保界面一致性。
- **生命周期触发**：调用 `componentDidMount`、`useEffect` 等副作用回调。

**典型操作**：  
```javascript
// 伪代码示例：提交阶段
function commitRoot() {
  遍历副作用链表;
  执行DOM插入/更新/删除;
  调用生命周期钩子;
}
```

#### **三者的协作流程**
1. **触发更新**：用户操作（如 `setState`）触发新任务，注册到 Scheduler。  
2. **任务调度**：Scheduler 按优先级将任务分片，在空闲时段调用 Reconciler。  
3. **协调计算**：Reconciler 构建 Fiber 树并标记变更，生成副作用链表。  
4. **渲染提交**：Renderer 同步执行副作用链表，更新真实界面。

#### **性能优化关键点**
- **Scheduler**：通过时间切片避免长任务卡顿，优先级调度提升交互响应。  
- **Reconciler**：Fiber 的异步可中断特性支持并发模式，增量渲染减少卡顿。  
- **Renderer**：批量更新减少 DOM 操作次数，自动合并多个 `setState`。

#### **面试考点总结**
- **架构分层**：Scheduler 管调度，Reconciler 管计算，Renderer 管渲染。  
- **Fiber 意义**：将递归更新转为可中断循环，支持并发和优先级调度。  
- **双缓冲树**：`current` 树对应当前界面，`workInProgress` 树存储待提交变更。  

**参考资料**：  
- [React Scheduler 源码解析](https://zhuanlan.zhihu.com/p/667749065)  
- [React 底层架构解析](https://juejin.cn/post/7395866692771627048)

### 时间切片
**React的时间切片机制主要针对其自身的渲染流程（如Fiber节点的遍历、协调和提交阶段），而不会对开发者编写的同步JS代码进行自动切割。如果业务逻辑中存在长时间阻塞主线程的同步计算，仍会导致页面卡顿。**
#### 解决方案
##### 主动拆分任务
将长任务分解为异步可中断单元，结合requestIdleCallback或setTimeout：
```js
  async function chunkedTask(data) {
    for (let chunk of splitIntoChunks(data)) {
      await new Promise(resolve => setTimeout(resolve, 0));
      processChunk(chunk);
    }
  }
```
##### 使用Web Worker
将CPU密集型计算移至Worker线程，避免阻塞主线程：
```js
  const worker = new Worker('calc.js');
  worker.postMessage(data);
  worker.onmessage = (e) => { /* 更新状态 */ };
  ```
##### 优化渲染层级
通过React.memo、useMemo减少不必要的渲染，降低React自身调度压力。

### 时间切片实现机制
React的时间切片实现基于其内部调度系统（Scheduler）和Fiber架构，核心目标是将长任务拆分为可中断的小任务，利用浏览器空闲时间执行。以下是实现机制的关键要点：

#### 一、调度器（Scheduler）的核心机制
1. **任务拆分与队列管理**  
   React将渲染任务拆分为多个工作单元（Fiber节点），存入任务队列。每个工作单元对应一个Fiber节点，包含优先级、过期时间等元数据。

2. **宏任务调度**  
   - **不使用`requestIdleCallback`**：因兼容性和执行时机不可控（如无法保证每帧执行），React选择**MessageChannel**或**setTimeout**模拟空闲回调。
   - **MessageChannel优先**：`MessageChannel`的`postMessage`回调执行时机比`setTimeout`更早且精准，仅在兼容性不足时降级为`setTimeout`。

3. **时间片控制**  
   - 默认每帧分配**5ms**作为时间片（可动态调整）。  
   - 通过`performance.now()`获取精确时间戳，判断剩余时间是否足够执行下一个任务。若时间耗尽，则挂起任务并交还主线程。

```javascript
// 伪代码示例：调度循环
function workLoop() {
  while (currentTask && hasTimeRemaining()) {
    currentTask = performUnitOfWork(currentTask); // 处理单个Fiber节点
  }
  if (currentTask) requestHostCallback(workLoop); // 继续调度
}
```

#### 二、Fiber架构的支撑
1. **链表结构中断与恢复**  
   Fiber节点以链表形式组织，每个节点保存父节点（`return`）、子节点（`child`）和兄弟节点（`sibling`），支持从任意节点中断并恢复遍历。

2. **优先级系统**  
   任务分为4级优先级（Immediate/UserBlocking/Normal/Low），通过`expirationTime`标记过期时间。高优先级任务可抢占低优先级任务。

3. **双缓存机制**  
   维护两棵Fiber树（current和workInProgress），交替更新以避免渲染过程中的视觉不一致。

#### 三、动态调整策略
1. **设备性能感知**  
   根据设备性能（如CPU负载、帧率）动态调整时间片长度。高性能设备可能延长单次任务时间，低端设备缩短时间片以避免卡顿。

2. **启发式任务排序**  
   调度器结合任务优先级、过期时间和设备状态，动态决定任务执行顺序。例如，用户输入触发的更新优先级高于数据加载。

#### 四、源码实现关键点
1. **任务调度入口**  
   通过`unstable_scheduleCallback`注册任务，传入优先级和回调函数，生成任务对象并加入队列。

2. **宏任务触发**  
   使用`MessageChannel`的`port.postMessage`或`setTimeout`触发任务执行，确保在浏览器空闲时段执行。

```javascript
// 使用MessageChannel触发任务
const channel = new MessageChannel();
channel.port1.onmessage = () => {
  if (currentTask) workLoop();
};
function requestHostCallback() {
  channel.port2.postMessage(null);
}
```

3. **中断与恢复逻辑**  
   在`workLoop`中，若检测到时间耗尽或更高优先级任务到达，则保存当前Fiber节点状态，退出循环并等待下一次调度。

#### 总结
React时间切片的实现本质是**将同步渲染转为异步可中断任务**，结合调度器的宏任务调度、Fiber的链表中断恢复和动态优先级控制，确保主线程不被长时间阻塞。开发者无需手动干预，但需避免在组件渲染中编写同步长任务，以充分发挥时间切片的优势。