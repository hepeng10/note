## 如何计算白屏时间和首屏时间
白屏时间: window.performance.timing.domLoading - window.performance.timing.navigationStart
首屏时间: window.performance.timing.domInteractive - window.performace.timing.navigationStart

## 浏览器渲染流程
[浏览器渲染流程](./WEB前端相关/视频与书籍/浏览器工作原理与实践/1.宏观上的浏览器.md#渲染流程)
[重绘、重排](./WEB前端相关/视频与书籍/浏览器工作原理与实践/1.宏观上的浏览器.md#相关概念)
除了重绘和重排，还有个直接合成。使用 CSS 的 transform 是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

## 中断 fetch
需要使用 AbortController 和 signal。
```js
let controller;
const url = "video.mp4";

const downloadBtn = document.querySelector(".download");
const abortBtn = document.querySelector(".abort");

downloadBtn.addEventListener("click", fetchVideo);

abortBtn.addEventListener("click", () => {
  if (controller) {
    // 使用 AbortController 对象可以 abort
    controller.abort();
    console.log("下载已中止");
  }
});

async function fetchVideo() {
  // 创建 AbortController
  controller = new AbortController();
  // 获取 signal
  const signal = controller.signal;

  try {
    // fetch 请求传入 signal
    const response = await fetch(url, { signal });
    console.log("下载完毕", response);
    // 进一步处理请求
  } catch (err) {
    console.error(`下载出现错误：${err.message}`);
  }
}
```

## 防抖和节流
**防抖(debounce)**
触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间
100ms 的防抖，触发后 50ms 再次触发，则重新计算时间。如搜索框连续输入，只有当输入完成后一定时间没有再次输入才请求。
示例代码
```js
// 防抖函数
function debounce(f, wait) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      f(...args);
    }, wait);
  };
}
// 使用
window.onresize = debounce(function () {
  console.log("resize");
}, 500);
```

**节流(throttle)**
高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率
示例代码
```js
function throttle(f, wait) {
  let timer;
  return (...args) => {
    if (timer) {
      return;
    }
    timer = setTimeout(() => {
      f(...args);
      timer = null;
    }, wait);
  };
}
```

## 实现一个 Promise
```js
class Prom {
  static resolve(value) {
    if (value && value.then) {
      return value;
    }
    return new Prom((resolve) => resolve(value));
  }
 
  constructor(fn) {
    this.value = undefined;
    this.reason = undefined;
    this.status = "PENDING";
 
    // 维护一个 resolve/pending 的函数队列
    this.resolveFns = [];
    this.rejectFns = [];
 
    const resolve = (value) => {
      // 注意此处的 setTimeout
      setTimeout(() => {
        this.status = "RESOLVED";
        this.value = value;
        this.resolveFns.forEach(({ fn, resolve: res, reject: rej }) =>
          res(fn(value)),
        );
      });
    };
 
    const reject = (e) => {
      setTimeout(() => {
        this.status = "REJECTED";
        this.reason = e;
        this.rejectFns.forEach(({ fn, resolve: res, reject: rej }) =>
          rej(fn(e)),
        );
      });
    };
 
    fn(resolve, reject);
  }
 
  then(fn) {
    if (this.status === "RESOLVED") {
      const result = fn(this.value);
      // 需要返回一个 Promise
      // 如果状态为 resolved，直接执行
      return Prom.resolve(result);
    }
    if (this.status === "PENDING") {
      // 也是返回一个 Promise
      return new Prom((resolve, reject) => {
        // 推进队列中，resolved 后统一执行
        this.resolveFns.push({ fn, resolve, reject });
      });
    }
  }
 
  catch(fn) {
    if (this.status === "REJECTED") {
      const result = fn(this.value);
      return Prom.resolve(result);
    }
    if (this.status === "PENDING") {
      return new Prom((resolve, reject) => {
        this.rejectFns.push({ fn, resolve, reject });
      });
    }
  }
}
 
Prom.resolve(10)
  .then((o) => o * 10)
  .then((o) => o + 10)
  .then((o) => {
    console.log(o);
  });
 
return new Prom((resolve, reject) => reject("Error")).catch((e) => {
  console.log("Error", e);
});
```

## JSON stringify 特性
```js
const obj = {
  a: 3,
  b: 4,
  c: null,
  d: undefined,
  get e() {},
};
 
console.log(JSON.stringify(obj));
```
会输出：
```js
{"a":3,"b":4,"c":null}
```
其中的 undefined，function 将在 JSON.stringify 时会忽略掉。

## 使用 fetch 流式处理网络请求
AI 文本接口返回的数据要实现内容逐渐显示的功能可以使用 fetch 的 EventStream。
> EventStream 是建立浏览器与服务器之间的通信渠道，由服务器向浏览器推送信息（对比 websocket 它属于 单向通信）。 另外它会对 HTTP 服务器开启一个持久化的连接，以 text/event-stream 流的形式向浏览器推送信息，直到一方手动触发关闭。
```js
// client.js
const fetchStream = async (url, options) => {
  const response = await fetch(url, options);
  const reader = response.body.getReader();

  while (true) {
    const { value, done } = await reader.read();
    if (done) {
      console.log('done.');
      break; // 读取完毕
    } else {
      console.log('message: ', new TextDecoder().decode(value));
    }
  }
}

fetchStream('http://127.0.0.1:5000/stream', { method: 'get', headers: { 'Content-Type': 'application/json' } });
```
1）服务端返回的 Stream，浏览器会识别为 ReadableStream 类型数据，执行 getReader() 方法创建一个读取流队列，可以读取 ReadableStream 上的每一个分块数据；
2）通过循环调用 reader 的 read() 方法来读取每一个分块数据，它会返回一个 Promise 对象，在 Promise 中返回一个包含 value 参数和 done 参数的对象；
3）done 负责表明这个流是否已经读取完毕，若值为 true 时表明流已经关闭，不会再有新的数据，此时 result.value 的值为 undefined；
4）value 是一个 Uint8Array 字节类型，可以通过 TextDecoder 转换为文本字符串进行使用。

## 事件循环
[事件循环，宏任务、微任务](./WEB前端相关/视频与书籍/浏览器工作原理与实践/3.浏览器中的页面循环系统.md)

## http 常见状态码
200 成功。301 永久重定向。302 临时重定向。304 触发缓存，header 中会有 If-Modified-Since, If-None-Match。401 没有访问权限（一般是未登录）。403 已登录但没有权限。404 客户端的请求地址找不到。500 服务器出错（笼统的错误）。502 网关错误。503 服务器现在无法为请求提供服务。

## http 缓存（协商缓存，强缓存）
[缓存](../网络/HTTP权威指南/HTTP权威指南.md#缓存)
**强缓存**：服务器用 HTTP/1.0+ 的 Expires 首部或 HTTP/1.1 的 **Cache-Control: max-age** 响应首部来指定过期日期或使用期。在这时间内重复访问，将触发 强缓存，响应状态码为 200 from cache。
**协商缓存**：HTTP 允许缓存向原始服务器发送一个“条件 GET” 请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体。在 header 中通过 **If-None-Match: \<tags\>** HTTP 允许用户对被称为实体标签（ ETag ）的“版本标识符” 进行比较。当通过 ETag 判断没过期时，会返回 304 not modified，浏览器就会从本地缓存获取。
强缓存不用和服务端通信，直接从缓存里取，状态码是200（memory cache/disk cache）。协商缓存需要和服务器通信，服务器判断缓存没过期，返回304状态码，浏览器会从缓存里取，但是没有 memory cache/disc cache。

## 三次握手和四次挥手
[三次握手和四次挥手](../网络/HTTP权威指南/HTTP权威指南.md#三次握手)
在TCP/IP协议中，SYN、ACK和FIN是用于建立和终止连接的标志位，它们在三次握手和四次挥手中起着关键作用。

1. **SYN（Synchronize Sequence Numbers）**：**同步序列编号**。当一个客户端想要开始一个与服务器的新会话时，它发送一个带有SYN标志位设置为1的数据包给服务器。**这表示请求建立连接**，并且该数据包还包含客户端初始的序列号，用于开始数据传输的协调。

2. **ACK（Acknowledgment field significant）**：**确认字符**。ACK标志位被用来表示应答，即确认收到对方发送的数据。在TCP连接建立之后，每一个数据传输都会包含一个ACK来确认收到了先前的数据包。在三次握手中，ACK标志位用来响应接收到的SYN信息，**表示已接收到了对方的同步请求，并愿意建立连接**。

3. **FIN（Finish）**：**结束标志**。当一方完成了数据的发送，**想要关闭连接**时，会发送一个FIN标志位设置为1的数据包给另一方。这标志着该方向上的数据发送完成，但并不意味着双方的通信立刻结束，因为对方可能还有未发送完的数据或未确认的数据。

- **三次握手**：
  - 第一步：客户端发送一个SYN包到服务器，表示希望建立连接。
  - 第二步：服务器回复一个SYN/ACK包，既是对客户端SYN的响应（ACK），也同时发送自己的SYN，表示也希望建立连接。
  - 第三步：客户端收到SYN/ACK后，发送一个ACK包作为对服务器SYN的响应，连接建立完成。

- **四次挥手**：
  - 第一步：任意一方都可以首先发送FIN包以启动断开连接的过程。假设客户端先发送，则此步骤客户端向服务器发送FIN包。
  - 第二步：服务器回复一个ACK包，确认收到客户端的FIN包。
  - 第三步：随后，服务器发送自己的FIN包给客户端，表示同意关闭连接。
  - 第四步：客户端发送ACK包响应服务器的FIN，等待一段时间确保服务器收到ACK后，双方连接正式关闭。

通过这种方式，TCP能够保证可靠地建立和终止连接，同时也确保了数据传输的可靠性。

#### 为什么“握手”是三次，“挥手”却要四次？
建立连接时，被动方服务器端结束 CLOSED 阶段进入“握手”阶段并不需要任何准备，可以直接返回 SYN 和 ACK 报文，开始建立连接。
释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回 ACK 确认收到报文，经过 CLOSE-WAIT 阶段准备好释放连接之后，才能返回 FIN 释放连接报文。

## HTTP2 的改进
HTTP/2引入了多项改进以提高网络性能和效率，主要体现在以下几个方面：

1. **多路复用（Multiplexing）**：在HTTP/1.x中，每个请求都需要建立一个新的TCP连接，这导致了高延迟，尤其是在存在大量资源请求时。**HTTP/2允许通过单一的TCP连接同时发送多个请求和响应**，解决了线头阻塞的问题，并显著提高了页面加载速度。

2. **头部压缩（Header Compression）**：HTTP请求和响应的头部信息通常包含重复数据，**HTTP/2采用HPACK算法对这些头部进行压缩传输**，减少了不必要的网络流量，特别是对于移动设备来说，这一改进尤为重要。

3. **服务器推送（Server Push）**：**此功能允许服务器主动向客户端发送资源，而无需等待客户端明确请求**。例如，当用户访问一个网页时，服务器可以预先推送可能会被请求的资源如CSS、JavaScript文件等，从而减少用户等待时间。

4. **增强的安全性**：虽然HTTP/2协议本身并不强制要求使用加密，但**大多数浏览器厂商仅支持基于TLS的HTTP/2，即HTTPS**。这意味着实际上大多数HTTP/2通信都是加密的，增强了数据传输的安全性和隐私保护。

5. **二进制分帧层（Binary Protocol）**：与HTTP/1.x使用的文本协议不同，HTTP/2采用了二进制分帧层来定义消息如何封装。**这不仅使得解析更加高效，而且降低了错误发生的可能性，提升了协议的整体效率和可靠性**。

综上所述，HTTP/2的这些改进有助于减少延迟、加快页面加载速度、降低带宽使用，并且提供更好的安全性，为现代Web应用的发展提供了强有力的支持。

尽管HTTP/2引入了许多改进，但它也存在一些缺点和挑战：

1. **复杂的实现**：HTTP/2的复杂性比其前代更高，特别是对于服务器端和客户端软件的开发者来说，理解和正确实现HTTP/2的新特性（如多路复用、头部压缩等）可能更加困难。这可能导致实现上的错误或性能问题。

2. **单个TCP连接的问题**：虽然多路复用减少了建立多个TCP连接的需求，但这也意味着所有数据流都依赖于单一的TCP连接。如果这个连接出现丢包或错误，那么整个HTTP/2连接的所有数据流都会受到影响，这种现象被称为“队头阻塞”。

3. **不完全支持所有HTTP/1.x的功能**：尽管大多数功能得到了保留或改进，但在过渡期间，某些特定的HTTP/1.x实践可能需要重新考虑或调整以适应HTTP/2的变化。例如，HTTP/2不再推荐使用域名分片（domain sharding），因为这与多路复用的目标相冲突。

4. **加密并非强制但几乎必需**：尽管HTTP/2规范本身并不强制要求使用TLS加密，但是主流浏览器只支持基于TLS的HTTP/2，即HTTPS。这意味着想要充分利用HTTP/2的优势，网站必须采用HTTPS，这对一些网站来说可能是额外的成本和技术挑战。

5. **调试难度增加**：由于采用了二进制协议而不是HTTP/1.x的文本协议，调试HTTP/2流量变得更加困难。开发人员需要专门的工具来解析和理解HTTP/2的通信内容。

6. **资源消耗**：在某些情况下，HTTP/2可能会导致更高的内存和CPU使用率，特别是在处理大量并发连接时。这是因为维持一个高效的HTTP/2连接需要更多的状态管理和更复杂的帧处理逻辑。

综上所述，虽然HTTP/2带来了显著的性能提升，但也伴随着一些新的挑战和限制，这些都需要在实际部署和使用中予以考虑。

## 原型和原型链
原型分为显式原型和隐式原型，函数的 prototype 属性是显式原型，对象的 \_\_proto__ 是隐式原型。
```js
function Person(name, age) {
    // 成员属性写在构造函数内，创建的每个对象都是独立的
    this.name = name;
    this.age = age;
}
// 成员方法写在原型上，所有对象共享，节约空间
Person.prototype.say = function() {
    console.log('hello, I am ', this.name);
};
const p1 = new Person('Tirion', 20);
// 构造函数的的显示原型 prototype 是个对象，所以也有 __proto__，指向 Object.prototype
console.log(Person.prototype.__proto__ === Object.prototype); // true
// 构造函数原型上的构造方法指向构造函数本身
console.log(Person.prototype.constructor === Person); // true
// 构造函数的 __proto__ 指向 Function.prototype
console.log(Person.__proto__ === Function.prototype); // true
// 对象的 __proto__ 指向它的构造函数的 prototype
console.log(p1.__proto__ === Person.prototype); // true
// 对象的 constructor 指向它的构造函数
console.log(p1.constructor === Person); // true
// 对象没有显式原型，构造函数才有
console.log(p1.prototype); // null
// Function 是个构造函数，所以它的 prototype.__proto__ 也指向 Object.prototype
console.log(Function.prototype.__proto__ === Object.prototype); // true
// Object 是个构造函数，所以它的 __proto__ 指向 Function.prototype
console.log(Object.__proto__ === Function.prototype); // true
```
原型链就是通过原型不断的往上指形成的一个链表。

