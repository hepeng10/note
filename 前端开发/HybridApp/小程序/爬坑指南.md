# 全局样式名冲突
在开发百度小程序时发现各种操作都会触发闪屏，后来经过排查，发现是项目中定义了一个全局样式名:
```css
.none {
    display: none;
}
```
而这个 .none 的 class 名在百度小程序中有内置的一个 class 名也叫 none，命名冲突导致各种操作都会闪屏，改个名字就好了。
**所以，在小程序开发时要尽量避免使用全局样式，命名时也要注意不要使用简单的常用名。。。**

# 开发者工具不支持 gzip
字节开发者工具调用接口出现乱码，经排查发现是后端开启了 gzip 导致的，然后发现手机上真机调试没问题，那说明是开发者工具的问题。解决办法是开发环境关闭 gzip 压缩提高开发效率，正式环境开启 gzip 压缩提高性能。
微信开发者工具也出现过上传接口返回数据时乱码，也是 gzip 导致的，所以开发环境别开 gzip 压缩。

# https
* 图片支持 http 访问，但是不支持不安全的 https 访问。
* 在体验版中，微信小程序支持开启调试模式使用 http 请求来测试，但是其它小程序即使体验版也需要 https，所以开发多端小程序时开发阶段就该使用 https。

# createInnerAudioContext
百度小程序 Taro.createInnerAudioContext() 必须放在组件内部，不能在模块根级中实例化。即函数组件必须在函数内部调用，class 组件必须在 class 中调用。

# 动画 createAnimation
动画不建议使用 CSS3 来实现，而应该使用 createAnimation。而使用 createAnimation 时也有许多注意事项。
1. 创建 animation 的时候应该使用 useRef。
2. 动画元素如果是通过事件触发由隐藏变为显示再执行动画，那么设置动画需要延迟执行，也就是动画元素显示后下一帧再进行动画设置。
3. 由于没有使用 useState 存储动画，所以在设置动画后还需要通过一个 setState 来触发一次页面渲染。
```tsx
const Rotate = () => {
  const aniMain: Animation = createAnimation({
    duration: 1000,
    timingFunction: 'linear'
  });
  const aniBack: Animation = createAnimation({
    duration: 1000,
    timingFunction: 'linear'
  });
  const animationMain = useRef<AnimationExport>(aniMain.export());
  const animationBack = useRef<AnimationExport>(aniBack.export());

  const [visible, setVisible] = useState<boolean>(false);
  const [active, setActive] = useState<boolean>(false);
  const animation = () => {
      setVisible(true);  // 显示动画元素
      // 延迟设置动画
      setTimeout(() => {
        aniMain.rotateY(0).step();
        aniBack.rotateY(180).step();
        animationMain = aniMain.export();
        animationBack = aniBack.export();
        setActive(true); // 需要 setState 触发页面更新
      }, 100);
  };

  return (
      {
          visible
            ?
            <View className={styles.test}>
                <View
                  className={cns(styles.box, styles.b1)}
                  animation={animationMain.current}
                >
                    <Image
                        className={styles.img}
                        src="https://nm.test.jgjapp.com/public/imgs/my/signin/winningbg.png"
                    ></Image>
                </View>
                <View
                  className={cns(styles.box, styles.b2)}
                  animation={animationBack.current}
                >
                    <Image
                        className={styles.img}
                        src="https://nm.test.jgjapp.com/public/imgs/my/signin/back.png"
                    ></Image>
                </View>
            </View>
            :
            null
      }
  );
}
```

# 登录
wx.login() 获取登录凭证 code，同时会在小程序服务器上生成一份 session_key。但是短时间内多次调用 wx.login() 不一定会更新服务器的 session_key。如果服务器上的 session_key 没更新，用新的 code 去登录或加解密用户数据就会会导致失败。所以应该通过 wx.checkSession() 判断服务器是否有 session_key，没有则调用 wx.login() 生成 code 保存到本地，其它地方使用 code 的时候就从本地获取。而在使用 code 的地方也应该使用 wx.checkSession() 进行验证，如果过期了还是得调一次 wx.login() 来获取新的 code 和生成新的 session_key。

# 元素放在 web-view 之上
[小程序web-view覆盖原生组件](https://blog.csdn.net/WEIGUO19951107/article/details/94305964)
微信可以通过 css hack 让元素放到 web-view 之上，只有真机调试才有效。
```tsx
  <WebView src="https://www.baidu.com">
    <CoverView className="share-button">
      <CoverView className="share-txt" onClick={}>
        搭配详情
      </CoverView>
      <CoverView className="share-txt">
        商品列表
      </CoverView>
    </CoverView>
  </WebView>
```
```css
.share-button {
  z-index: 999999;
  position: fixed;
  color: white;
  text-align: center;
  display: flex;
  justify-content: center;
  align-items: center;
  border-radius: 50%;
  top: 100rpx;
  width: 60%;
  height: 72rpx;
  display: flex;
  left: 20%;
  justify-content: center;
  background: black;
}

.share-txt {
  width: 200rpx;
  height: 72rpx;
  box-shadow: 0rpx 4rpx 6rpx 0rpx rgba(18, 46, 102, 0.5);
  border-radius: 36rpx;
  line-height: 72rpx;
  text-align: center;
  font-size: 28rpx;
}

.share-txt {
  margin-right: 40rpx;
}
```

# 百度移动统计导致 onShareAppMessage 失效
百度移动统计会在每个页面注入 onShareAppMessage，从而在全局添加的分享功能会出问题，如果不需要统计可以将 onShareAppMessage 相关内容删除。
```ts
  // 全局添加分享功能
  addShareMenu() {
    Taro.showShareMenu({
      withShareTicket: true,
      // @ts-ignore
      menus: ['shareAppMessage', 'shareTimeline'], // 加了这个才能分享朋友圈
      showShareItems: ['shareAppMessage', 'shareTimeline']
    });
    const page = getCurrentInstance().page;
    // 判断当前页没有配置 onShareAppMessage 才添加
    if (page && !page.onShareAppMessage) {
      page.onShareAppMessage = () => {
        console.log('分享好友');
        return {
          title: page.config?.navigationBarTitleText || '建筑招工找活',
          imageUrl: 'http://xxx.xxx.xxx/xxx.jpg'
        };
      };
    }
  }
```
另外页面配置文件中的配置了 enableShareAppMessage 也会给当前页面添加 onShareAppMessage，从而导致当前页不会走全局分享配置。
```ts
export default {
  navigationBarTitleText: '吉工家  找工作；招工网；招工；找活；招工信息',
  enablePullDownRefresh: true,
  enableShareAppMessage: true  // 配置了这个不会走全局分享；如果要走当前页面的分享也必须配置这个，否则可能获取不了当前页的 onShareAppMessage
};
```

# showToast 图片路径
使用 showToast 时传入图片，不能通过 import 图片直接传给 image 属性，只能给 image 设置图片的绝对路径。而图片的绝对路径是在编译后的文件目录中，通过开发者工具来查看，通常会打包到项目的根目录下。
想让图片打包到编译后的文件中，那么有两种方式。
1. 主包 import 并使用了的图片。
2. 通过 config/index.js 中配置 copy 字段指定将文件打包到编译后的目录中。

第一种方法比较简单方便，但是 toast 使用的图片通常不会在主包中用到，这就不行了，虽然可以在主包中专门去使用并隐藏起来，从而达到打包的目的，但是这样就有点不好。还是使用第二种方式更好一点。

配置 copy 字段：
```js
  copy: {
    patterns: [{
      from: 'src/images/toast',  // 源码中的路径
      to: 'dist/weapp/images/toast'  // 打包后的路径
    }],
    options: {}
  },
```
可以看到我们将目录 copy 到了 dist/weapp 目录下。使用这种方式的问题就在于，多端开发的时候如果每个端都要使用，那么就要对每个端进行配置才行。

# 启动页
启动页就是一个普通的页面。
1. 小程序的首页就设置为启动页
2. 分享的时候通过配置 onShareAppMessage 将所有分享页都配置到启动页，然后在 url 中通过参数传入当前页，注意使用 encodeURIComponent 编码。

这样就能保证用户在启动小程序的时候都是先进入启动页，如果有跳转参数启动后跳转到对应页面，没有就跳转到首页。
当有启动页之后，我们在 onLaunch 的时候通过接口获取的信息基本上就能保证有效了。
比如如果直接进入分享页，我们在 onLaunch 时获取用户信息，分享页需要用到用户信息去获取其它数据，但是获取用户信息的接口可能比较耗时，这时调用获取其它数据的接口就有问题。但是有了启动页，我们在启动页就获取用户信息，获取成功或等待数秒跳到分享页，那么到了分享页调各种接口也就没问题了。

另一个问题是跳转到分享页后用户返回上一个页面就会返回到启动页，这个问题可以在启动页使用 redirectTo 跳转的时候关闭当前页面来解决。

# Taro 环境变量 NODE_ENV
Taro 的环境变量 NODE_ENV 只支持 development 和 production，设置成其它值如 test 在打包时就会报错！
所以环境变量最好别用它的 NODE_ENV，自建一个其它变量如 APP_ENV 来代替。Taro 自带的 NODE_ENV 只是在打包时给框架或者第三方库用于性能优化使用的。（也许在普通 web 应用中也应该这样）

# Taro 通过 package.json 传参
我们经常会通过 package.json 的 scripts 对项目进行参数配置，通常也会使用 cross

# lottie 动画
小程序中使用 lottie 动画只能使用 lottie-miniprogram 这个第三方作者移植的库。这个库只能使用 canvas 绘制，对 lottie 动画中的渐变效果不支持，会渲染成相同的色块。

使用 lottie 动画
```jsx
import { createSelectorQuery, getSystemInfoSync } from '@tarojs/taro';

export function initLottie(param: Param) {
  let { screenWidth, path, data, loop = true, autoplay = true, onComplete } = param;
  let ani;
  setTimeout(() => {  // 延迟一下执行避免 canvas 元素未完成渲染
    createSelectorQuery()
      .select('#canvas')  // 获取 canvas 元素
      .node((res) => {
        const canvas = res.node;
        const context = canvas.getContext('2d');

        canvas.width = getSystemInfoSync().screenWidth * 3, // 乘以3提高3倍分辨率，避免图片模糊
        canvas.height = getSystemInfoSync().screenWidth * 3, // 乘以3提高3倍分辨率，避免图片模糊

        lottie.setup(canvas);
        ani = lottie.loadAnimation({
          path,  // json 文件的路径。和 animationData 使用其中之一就行
          animationData: data,  // import json 文件的数据
          loop: loop,  // 是否循环播放
          autoplay: autoplay,  // 是否自动播放
          rendererSettings: {  // 传入 context 就行
            context
          }
        });
        ani.onComplete = () => {  // 动画完成事件
          onComplete && onComplete();
        };
      })
      .exec();  // 执行动画
  }, 100);
}


<Canvas
  style={{
    width: getSystemInfoSync().screenWidth,
    height: getSystemInfoSync().screenWidth,
    position: 'fixed',
    top: 60,
    zIndex: 999
  }}
  className="canvas"
  id="canvas"
  type="2d"  // type 为 2d 或 webgl
></Canvas>
```

# SourceMap
在开发企业微信小程序时，发现没有 sourceMap，开发者工具中很难调试。通过查看文档，配置了开启 sourceMap 也无效，然后开启 debugReact 后能正常使用了。当然，最好判断下开发环境，或者通过 cross-env 传参来开启。
```js
  mini: {
    debugReact: process.env.NODE_ENV === 'development',
  }
```

新方法：微信开发者工具-设置-扩展设置-调试器插件 安装 sourceMap 匹配调试插件，然后在 config/dev.js 中配置 mini 添加 sourceMapType: 'source-map'，即使在 dev.js 中使用了 TerserPlugin 也能支持 sourcemap。

# Taro.previewImage
百度小程序使用 Taro.previewImage 预览图片，只能用线上图片，不能使用本地的，所以上传图片后进行预览要注意不要使用临时文件直接预览。

# 图片闪动问题
在使用 Image 组件的时候， mode 设置为 widthFix, heightFix 可以让另一边自适应，但是这个自适应是通过 js 动态计算加到 Image 组件上的 style 属性中，而在这个计算过程中图片不会自适应，就会出现图片闪动的情况。所以 Image 组件即使使用了 widthFix, heightFix 也要在 css 里写上 width 和 height 避免闪烁。自适应的那条边长度不用那么精准也行，可以利用 style 属性的优先级让图片显示比例更准确。

# ScrollView 的 refresherEnabled
当 ScrollView 组件开启了 refresherEnabled 即下拉刷新后，ScrollView 会添加 transform 属性实现下拉。但是这就导致了 CSS3 中的 transform 属性的坑。在 CSS3 中，拥有 transform 属性的容器中的元素，若设置 position: fixed，则 fixed 会降级为 absolute。所以在开启 refresherEnabled 的 ScrollView 中写遮罩层组件会无法覆盖 ScrollView 外的具有 position: fixed 属性的其它元素。而且 ScrollView 内使用 fixed 定位的元素也会随着页面滚动。解决方法可以将元素设置 position: sticky 定位，当然最好还是在设计上就进行避免。
> 在 react 中可以使用 react.createPortal() 方法来将一个组件渲染到指定的 dom 元素上，也就是可以渲染到 transform 之外的元素中。但是小程序不支持 dom 操作，所以不能使用。

# iPhone X, iPhone 13 等机型 1rpx 边框
在 iPhone X, iPhone 13 等机型中，设置 border: 1px 时，即在小程序中为 1rpx，会出现下边边框不显示的问题.是因为 1rpx 在手机上实际是 0.5px，而这些手机显示0.5px就会出问题。解决方法是在元素上加上 transform: translateZ(360deg) 即可解决
```css
.btn {
  border: 1px solid black;
  transform: rotateZ(360deg);
}
```

# 分享
1. PC 端分享，useShareAppMessage 进行分享的时候，点击自定义分享按钮时不能进行异步操作，也就是不能在点击按钮的时候使用点击事件根据点击的按钮给一个变量赋值，然后在 useShareAppMessage 中取值，这样是取不到值的。只能给点击的按钮设置 data-xxx 属性才保存值，然后在 useShareAppMessage 中通过回调函数的参数 res.target.dataset 来获取设置的值进行分享。

# 手机授权登录
小程序中获取手机号授权登录，小程序必须为非个人开发者（基本信息中的主体信息），且完成了认证的小程序开放（基本信息中的微信认证）。

# 企微小程序
在开发企微小程序时，taro 中加了企微小程序的插件后，通过 --qywx 编译企微小程序后，通过 process.env.TARO_ENV 能拿到运行环境是 qywx，但是当我们开发的是个微小程序和企微小程序双端时，最终打包发版必然是通过 --weapp 进行打包后上传提审上线，这时即使在企微中打开小程序，我们拿到的 process.env.TARO_ENV 也是 weapp，所以没法通过 process.env.TARO_ENV 判断是不是企微中运行。最终只能通过下面的方法来判断是不是在企微中运行：
```ts
// 是否是企业微信环境
export function isQywx(): boolean {
  if (process.env.TARO_ENV === 'qywx') {
    return true;
  }
  // 使用个微模式打包，但是在企微中允许，拿到的 TARO_ENV 是 weapp，所以再判断次 wx.qy 是否存在，存在既是企微环境
  if (process.env.TARO_ENV === 'weapp' && wx.qy) {
    return true;
  }
  return false;
};
```

# useDidHide
在离开页面的生命周期不能通过 `getCurrentInstance()?.router?.path` 获取到正确的路由地址，所以如果需要在离开页面时获取路由，应该在进入页面时就先获取到赋值给变量。
```ts
const Index = () => {
  // 进入页面就获取路由
  const buriedRoute = useMemo(() => getBuriedRoute(), []);

  useDidHide(() => {
    reportJiZhiFn();
  });

  const reportJiZhiFn = () => {
    try {
      let reportData: Array<any> = [];
      exposureData.reportList.current.forEach((item, index) => {
        if (item.count !== 0) {
          reportData.push({
            event: 'display_business_card',
            time: Math.round(+new Date() / 1000),
            extra: {
              user_id: +(getStorageSync('userInfo')?.uid || ''),
              page: buriedRoute, // 离开页面使用变量即可
              uid: scrollViewList[index].uid,
            },
          });
        }
      });
      if (reportData.length > 0) {
        reportJiZhiLog('reportEvent', reportData);
      }
    } catch (error) {}
  };

```