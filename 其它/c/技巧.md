## 给二进制中的某些位赋值
开发中使用的寄存器等通常为8位、16位、32位这样的位数，很多编译器下，我们不能通过 0b 的方式使用二进制数字，只能通过 0x 的方式使用16进制数字。如 0xFA 就是 1111 1010。然而我们很多时候却要给寄存器赋值，比如8位寄存器我们就可以使用16进制直接赋值，如`P0 = 0xFA`。但是当我们要修改其中某些位的时候却比较麻烦，比如 P0 本来的值是 0101 1000，我们要将第34位的10改为01，其它位不变。这时就有个技巧：
```c
/**
 * 一次性修改多位
 */
P0 = 0x58; // P0 原本的值是 0x58 即 0101 1100
/**
 * 先将要修改的位变成0，就需要使用一个对应位为0，其它位为1的变量，即 1111 0011 -> 0xF3
 * 将 P0 与这个数按位与后，对应的位就变成了0。结果为 0101 0000
 */
P0 &= 0xF3;
/**
 * 要将34为改为01，所以需要用到的二进制为 0000 0100 -> 0x04
 * 将这个数和 P0 再进行按位或运算就得到最终结果了 0101 0100
 */
P0 |= 0x04;
```
如果我们只改其中某一位为1或0，其它位不变，就更简单一些。
```c
/**
 * 一次只改一位
 */
P0 = 0x58; // P0 原本的值是 0x58 即 0101 1100

// 要将第1为改成1，即 0101 1110，就与 "0000 0010" 进行"或"运算即可
P0 |= 0x02; // 要改的位为1，其它位为0，或运算
P0 |= (1 << 1); // 效果和上面那句一样，1左移1位更能体现要修改的位

// 要将第2位改成0，即 0101 1000，就与 "1111 1011" 进行"与"运算即可
P0 &= 0xFB; // 要改的位为0，其它位为1，与运算
P0 &= ~(1 << 2); // 效果同上。1左移2位再取反，就得到 1111 1011，也能体现要修改的位
```
使用移位运算后再和原来的数进行操作，使用起来更简单，不用去计算具体的十六进制，如果要修改多位那就多操作几次也行。

## 获取二进制中某一位是否为1
如变量 IDR 的二进制为 0101 1010，我们想知道第3位的值是否为1，那么就应该拿一个第三位是1，其它位都是0的数进行位与操作，即 `0101 1010 & 0000 1000`，如果第三位是1，那么就会得到 0000 1000，如果第三位是0就会得到 0000 0000。
但是要注意的是，我们不能拿结果去和1进行比较，因为 0000 1000 不等于1，而在我们看来获取的那一位是1。所以应该和0比较，只要结果不为0，就说明要获取的那一位是1；如果那一位是0，按位与的结果必然是0。
```c
// IDR 为 0101 1010，IDR3 为 0000 1000
if ((IDR & IDR3) != 0) {
    // ...
}
```

## 原码补码转换
原码转补码和补码转原码都可以用“取反加一”的操作得到。补码转原码实际上应该“减一取反”，但是结果是“取反加一”是相同的。
* 补码是 0111，减一为 0110，再取反为 1001。
* 补码是 0111，取反为 1000，再加一为 1001。
结果是一样的。

#### 原码，反码，补码的关系
原码 1000，反码 0111，补码 1000。
原码 + 反码 = 全为1 -> 1111，即 $2^4 - 1$。
由于补码是反码+1，所以
原码 + 补码 = 原码 + 反码 + 1，即 $2^4 - 1 + 1$ 即 $2^4$。
所以原码+补码就是往前进一位，后面全是0，即 10000。
**补码之所以叫补码，就是和原码相加后把原码补成了2的整次幂的数。在十进制中，3+7=10,7叫做3的补数，3也是7的补数。所以，补码是原码的补码，原码也是补码的补码。所以补码是原码取反加一，原码也是补码取反加一**

## 秒调用毫秒注意点
```c
// 这是个微秒定时器，接收参数是 uint16
void delayUs(uint16_t us)
{
  SysTick->LOAD = (SystemCoreClock / 1000000) * us; // Set reload register
  SysTick->VAL = 0; // Clear current value register

  SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk; // Start the timer
  // SysTick->CTRL |= 0x05;

  while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)); // Wait for the timer to expire

  SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk; // Stop the timer
}

/**
 * 这是毫秒定时器，通过调用微秒实现，接收的类型也是 uint16_t
 */
void delayMs(uint16_t ms)
{
  // 如果直接 x1000 调用微秒，那么类型是相同的，x1000 后可能超过微秒的最大值
  // delayUs(ms * 1000);

  // 所以使用 while 循环每一毫秒调用一次微秒，定时1000微秒
  while (ms--)
  {
    delayUs(1000); // Call delayUs function with 1000
  }
  
}

// 秒的逻辑同毫秒调用微秒
void delayS(uint16_t s)
{
  while (s--)
  {
    delayMs(1000); // Call delayMs function with 1000
  }
  
}
```

