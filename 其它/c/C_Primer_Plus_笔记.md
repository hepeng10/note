# 编译器
c 的编译器包括 GCC、Clang 等，编译 c 文件使用 cc （compile c）命令进行编译。安装了 GCC 和 Clang 的系统中，也可以使用 gcc 或 clang 命令进行编译。通常系统中带有 GCC 或 Clang 编译器，cc 命令是作为他们之一的别名使用。  
可以使用 `cc -v`, `gcc -v`, `clang -v` 来查看它们的版本。  
在 Windows 中需要安装 Cygwin 或 MinGW 来编译 c 代码，编译中生成的中间文件代码为 .obj，并且通常编译完成后不会删除。

# 预处理器
C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。
所有的预处理器命令都是以井号（#）开头。

\#define	定义宏
\#include	包含一个源代码文件
\#undef	取消已定义的宏
\#ifdef	如果宏已经定义，则返回真
\#ifndef	如果宏没有定义，则返回真
\#if	如果给定条件为真，则编译下面代码
\#else	#if 的替代方案
\#elif	如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码
\#endif	结束一个 #if……#else 条件编译块
\#error	当遇到标准错误时，输出错误消息
\#pragma	使用标准化方法，向编译器发布特殊的命令到编译器中

详情点击：[预处理器](https://www.runoob.com/cprogramming/c-preprocessors.html)

# main 函数
main 函数是 c 程序的入口，标准写法为：
```c
int main(void) {
    return 0;
}
```
这里要注意几点：
1. main 函数返回值为 int.
2. main 函数没有参数，所以参数为 void.
3. 由于返回值为 int 所以 return 0.
4. 但是编译器会自动给 main 函数加 return 0，所以可以省略写 return 0。注意只有 main 函数会这样，其它函数会 return void.

在某些教程中使用 void main 其实是不标准的，虽然大多数情况它能正常运行。

# 字面量后缀
在数字的后面可以添加字面量后缀来表示此数字的类型，如：100L、123U、12.3F 等。
```c
#include <stdio.h>
int main(void) {
    long n1 = 100L;
    unsigned n2 = 123U;
    float n3 = 12.3F;

    // 4294967295 是 unsigned int 的最大值
    int n3 = 4294967295; // 编译器会报错，值超过了 int 的最大值
    int n4 = 4294967295U; // 编译器通过，并且 n4 实际上是 unsigned int 类型，存储下了这个值
    int n5 = 1.2F; // 将一个指定为 float 的类型的数赋值给 int 类型，编译器会报错，并不会改变 n5 的类型为 float

    printf("%zd\n", sizeof(1.2)); // 输出8，浮点数默认为 double 类型
    printf("%zd\n", sizeof(1.2F)); // 输出4，指定了使用 float 类型来存储

    // 这里就比较特别了。
    // 由于使用了无符号整数 1U，此处会变成 有符号数 和 无符号数 的二元运算，导致的结果就是条件为正，但是实际上 -2 + 1U 的值是 -1
    // 所以要注意不要将无符号数和有符号数进行运算
    if (-2 + 1U > 0)
    {
        long a = 100L - 1;
        printf("%ld\n", a);
        printf("%d\n", -2 + 1U); // 输出-1
        printf("%d\n", -2 + 1U > 0); // 输出1
    }
}
```

# 整数溢出
可以把整数看作是汽车的里程表。当达到它能表示的最大值时，会重新从起始点开始。无符号和有符号整数它们主要的区别是，在超过最大值时，unsigned int 类型的变量从0开始；而 int 类型的变量则从−2147483648开始（即 int 类型的最小值，根据类型不同也会有所不同）。

其实就是补码最大值加1后的值，比如 char 类型占1字节即8位，无符号类型内存中的值就是 00000000 - 11111111 即 0 - 255，当255+1后为256，即11111111+1为100000000，但是 char 类型只有8位，所以是 00000000 即0。而有符号 char 则是 11111111 - 011111111 即 -128 - 127，当127+1即 01111111 + 1 为 11111111，所以成了-128。

**注：有符号类型的补码中首位为符号位，0表示正数1表示负数，00000000表示0，10000000不表示-0而是最小的负数，比如8位就是-128。所以负数要比正数多1。**

# 查看各种类型占用字节
以下是在 Mac 中的占用
```c
#include <stdio.h>

int main(void) {
    printf("%zd \n", sizeof(short)); // 2
    printf("%zd \n", sizeof(int));  // 4
    printf("%zd \n", sizeof(long)); // 8
    printf("%zd \n", sizeof(long long)); // 8
    printf("%zd \n", sizeof(float)); // 4
    printf("%zd \n", sizeof(double)); // 8
    printf("%zd \n", sizeof(char)); // 1
    printf("%zd \n", sizeof(_Bool)); // 1
    
    return 0;
}
```

# 转换说明
请求printf()函数打印数据的指令要与待打印数据的类型相匹配。例如，打印整数时 使用%d，打印字符时使用%c。这些符号被称为转换说明（conversion specification），它们指定了如何把数据转换成可显示的形式。  
**如果类型不匹配，那么输出的内容可能就会显得很莫名其妙。**  
具体的转换说明符参考：[转换说明表](https://www.cnblogs.com/ilegend/articles/2258701.html)

# 字符串
```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char c = 'A'; // 基本类型 char
    char s[40] = "这是个字符串"; // 派生类型 char 数组
    printf("%c\n", c); // 使用 %c 输出字符
    printf("%s\n", s); // 使用 %s 输出字符串
    printf("%d\n", c); // 会输出 A 对应的 ASCII 码
    printf("%d\n", s); // 会输出莫名的数值（所以类型必须要匹配）
    printf("%zd\n", strlen(s)); // 输出18
    return 0;
}
```
### 基本类型 char
基本类型 char 实际上是整数类型，存储的是一个字符的 ASCII 码，值用单引号，并且只能有一个在 ASCII 码中的字符。如中文不在 ASCII 码中，赋值给 char 会报错。

### 字符串 char 数组
当声明字符串时，应该使用 char 数组进行声明，并且使用双引号。由于字符串最后会有个 \0 结束符，所有实际上能存储的字符长度比声明时的长度少一位。**（但是我在 Mac 中测试，并未发现需要少输入一位，可能编译器不同？）**

### char 数组长度和中文
上面我们使用 `char s[40]` 定义了 s 的长度为40，由于1个 char 类型元素占用1字节，所以表示的是40字节。上面的内容为 `这是个字符串` 是6个中文字符，40个字节可以容纳6个中文字符，但是当我们改为 `char s[10]` 时，编译器就会发出警告，说我们的字符串太长了，是因为1个中文并不是只占用1个字节，中文不在 ASCII 编码中，属于 Unicode 编码，经测试1个中文字符占用的是3个字节，所以需要 `char s[18]` 才能正常编译。（上面 strlen(s) 输出18也能看出一个中文占用3个字节）
**Unicode 编码中的中文等字符存储在内存中也是二进制数字，一个汉字对应一个数值，3个字节足以表示各种语言的文字了。（计算机读取到 Unicode 编码内存位置时，应该会有某种机制告诉计算机这里存储的是 Unicode 编码，而不是普通的数字，读取后会使用 Unicode 编码进行解析成汉字输出。）**

# 常量
### 使用 #define 定义常量
\#define 又叫做宏，定义的常量又叫宏常量
```c
#include <stdio.h>
#define MAX 100 // 定义宏常量
#define ADD 1+2

int main(void) {
    int value1 = MAX * 2; // 使用宏常量
    int value2 = ADD * 3; // 替换后就会变成 1+2*3，结果不合预期
    return 0;
}
```
以上是使用 #define 定义了一个常量，在预处理时就会将使用的地方替换成定义的值，内存中并不会有一个叫 MAX 的常量。

### 使用 const 定义常量
const 定义的常量又叫不可变变量
```c
#include <stdio.h>

int main(void) {
    const int MAC = 100;
    const int ADD = 1 + 2;
    int value1 = MAC * 2;
    int value2 = ADD * 3; // 会是 3*3
    return 0;
}
```
具体区别可参考：[常量（const 和 #define 的区别）](https://blog.csdn.net/Mikchy/article/details/107072337)

# 运算
### 除法
c 语言中，整数除法返回的也是整数，这就导致整数相除产生的小数部分会被丢弃，所有在会使用到除法时，应该将变量定义为 float 或 double 等浮点数类型，而不应该定义为 int 这样的整数类型。
```c
#include <stdio.h>
int main(void)
{
    int a = 5;
    int b = 2;
    float c = 5;
    float d = 2;
    printf("%d\n", a / b); // 只会输出 2
    printf("%f\n", c / d); // 正常输出 2.500000
    printf("%f\n", a / d); // 正常输出 2.500000（整型与浮点型运算得到浮点型）
    printf("%d\n", a / d); // 这里用 %d 会导致编译器警告，并且输出的值错误
    return 0;
}
```
混合整数和浮点数计算的结果是浮点数。实际上，计算机不能真正用整数除以浮点数，编译器会把两个运算对象转换成相同的类型。本例中，在进行除法运算前，整数会被转换成浮点数。

# 运算符
除了常用的 + - * / % 之外，c 语言还提供了一些函数进行一些特定的运算操作。

### 求模运算
负数求模如何进行？如果第1个运算对象是负数，那么求模的结果为负数；如果第1个运算对象是正数，那么求模的结果也是正数：
11 / 5 得2，11 % 5 得1 
11 / -5 得-2，11 % -2 得1 
-11 / -5 得2，-11 % -5 得-1 
-11 / 5 得-2，-11 % 5 得-1

### sizeof 和 size_t
sizeof运算符以字节为单位返回运算对象的大小，运算对象可以是具体的数据对象（如，变量名）或类型。
**（在C中，1字节定义为char类型占用的空间大小。过去，1字节通常是8位，但是一些字符集可能使用更大的字节）。**
```c
#include <stdio.h>
int main(void)
{
    char str[10] = "你好";
    float f[10];
    printf("%zd\n", sizeof(str)); // 输出10
    printf("%zd\n", sizeof(char)); // 输出1
    printf("%zd\n", sizeof(int)); // 输出4
    printf("%zd\n", sizeof(f)); // 输出40，因为 float 占4个字节，10个 float 占40字节
    return 0;
}
```
C 语言规定，sizeof 返回 size_t 类型的值。而 size_t 并不是个新类型，而是某个标准类型的别名，使用 typedef 定义。C 头文件系统可以使用 typedef 把 size_t 作为 unsigned int 或unsigned long 的别名。这样，在使用 size_t 类型时，编译器会根据不同的系统替换标准类型。我们可以使用 %zd 转换说明来表示接受 size_t 类型。
（上面实例中如果使用 %d 接收 sizeof 返回值，编译器会提示应该使用 %lu 接收，即 unsigned long 类型，所以在 Mac 系统下 size_t 是 unsigned long 的别名。当然 Mac 中也可以使用 %lu 来接收 sizeof 返回值。）

# 类型转换
在使用不同类型进行运算时，C 语言会对类型进行转换后再运算，但是最好的做法是不要使用不同的类型进行运算。

### 类型转换规则
表达式中使用不同类型的转换规则：
1. 当类型转换出现在表达式时，无论是 unsigned 还是 signed 的 char 和 short 都会被 自动转换成 int，如有必要会被转换成 unsigned int。
2. 涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。
3. 类型的级别从高至低依次是 long double、double、float、unsigned long long、long long、unsigned long、long、unsigned int、int。例外的情况是，当 long 和 int 的大小相同时，unsigned int 比 long 的级别高。之所以 short 和 char 类型没有列出，是因为它们已经被升级到 int 或 unsigned int。
4. 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。
5. 当作为函数参数传递时，char 和 short 被转换成 int，float 被转换成 double。

**类型降级**——不同类型赋值时，被赋值类型比赋值类型更低级的转换规则：
1. 目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略。例如，如果目标类型是8位 unsigned char，待赋的值是原始值求模256。（260赋值给 unsigned char 会输出4）
2. 如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异。
3. 如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的。（通常的实现是直接截断小数部分。）

### 强制类型转换运算符
使用 (type)value 可以将 value 强制转换为 type 类型。
```c
#include <stdio.h>
int main(void)
{
    int a = 1.6 + 1.7;
    int b = (int)1.6 + (int)1.7;
    printf("%d\n", a); // 输出3
    printf("%d\n", b); // 输出2
    return 0;
}
```
本质上，两种类型转换都好不到哪里去，要考虑程序的具体情况再做取舍。

# 关系运算符
c 语言的关系运算符包括 `>, <, >=, <=, ==, !=` 6种，注意没有 JS 中 `===, !==` 这样的关系运算符，强类型语言都没有。
关系运算符可以使用 char 类型和 int 类型进行比较，因为 char 类型实际上也是 int 类型，会转换成 ASCII 中的数值。**但是字符串类型不能使用关系运算符进行比较，有专门的函数用于比较字符串，如 strcmp 函数。**

### 浮点数比较
虽然关系运算符也可用来比较浮点数，但是要注意：比较浮点数时，尽量只使用 < 和 >。因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等。例如，3乘以1/3的 积是1.0。如果用把1/3表示成小数点后面6位数字，乘积则是.999999，不等于1。使用 fabs() 函数（声明在math.h头文件中）可以方便地比较浮点数，该函数返回一个浮点值的绝对值（即，没有代数符号的值）。

### 什么是真
在 C 语言中，1表示真，0表示假。实际上非0的整数都是真，无论正负。而浮点数放到条件语句中编译器会给出警告，及时能作为真值继续运行。
```c
#include <stdio.h>
int main(void) {
    if (1) {} // 正常运行，为真
    if (0) {} // 正常运行，为假
    if (10) {} // 正常运行，为真
    if (-10) {} // 正常运行，为真
    if ('a') {} // 正常运行，为真
    if ('0') {} // 正常运行，为真
    if ('\0') {} // 正常运行，为假，char 类型的 \0 实际就是0
    if ("aaa") {} // 正常运行，为真
    if (1.2) {} // 编译器给出警告，为真
    // C 语言中没有 true 和 false
    if (true) {} // 编译器报错，中断运行
    if (false) {} // 编译器报错，中断运行
    int true = 1; // 我们甚至可以声明变量名为 true
}
```
**C 语言默认没有关键字 true 和 false，C99 提供了一个头文件 <stdbool.h> 定义了 bool 代表 _Bool，true 代表 1，false 代表 0。**
```c
#include <stdio.h>
#include <stdbool.h> // 布尔相关头文件
int main(void)
{
    bool a = true;
    if (a)
    {
        printf("%d\n", 'a' > 3);
    }
}
```

# 函数
C 语言中，函数通常使用先声明再定义的写法。
```c
#include <stdio.h>
// 函数声明（函数原型）：函数的返回类型，名称，参数个数及类型 
int getN(int);
// int getN(int n); 参数可以取名可以不取名，个人感觉不取名更简洁

int main(void)
{
    // 函数调用
    int n = getN(10);
    printf("%d", n);
}

// 函数定义：对函数的实现
int getN(int n) {
    return n;
}
```
C 语言中，函数需要先声明再调用。
1. 上面代码中如果删除函数声明，但是保留函数定义，编译器会给出警告。编译器在运行到 getN(10) 时，此时发现并没有 getN 函数，会产生一个函数的隐式声明，也就是编译器会帮我们声明 getN 函数，由于我们后面实现了 getN，所以程序没有出错。但是隐式声明是有风险的，程序员应该避免这样的错误。
2. 如果将函数声明和函数定义都删除，则会直接报错。虽然编译器会帮我们生成隐式声明，但是函数没有实现，所以无法调用。
3. 将 getN 函数定义放在 main 函数之前，此时不写函数声明也没问题，但是这不符合规范，通常是将 main 函数放在最前面，函数定义可能放在 main 后面或其它文件中。

### 任意多个参数函数
一些函数接受（如，printf() 和 scanf()）许多参数。例如对于 printf()，第1个参数是字符串，但是其余参数的类型和数量都不固定。对于这种情况，ANSI C 允许使用部分原型。例如，对于 printf() 可以使用下面的原型：
```c
int printf(const char *, ...);
```
这种原型表明，第1个参数是一个字符串，可能还有其他未指定的参数。C 库通过 stdarg.h 头文件提供了一个定义这类（形参数量不固定的）函数的标准方法。

### 尾递归
最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。这种形式的递归被称为尾递归（tail recursion），因为递归调用在函数的末尾。尾递归是最简单的递归形式，因为它相当于循环。

### 指数增长的递归
```c
unsigned long Fibonacci(unsigned n)
{
    if (n > 2)
        return Fibonacci(n - 1) + Fibonacci(n - 2);
    else
        return 1;
}
```
上面是个计算斐波那契数列的递归，每次递归都会调用两次自身，所以创建的变量每次递归都是上次的两倍，这就是指数级增长的递归。所以在编写递归程序里要避免在递归中多次调用自身。

# 字符处理
### getchar 和 putchar
getchar 和 putchar 是 stdio.h 中定义的预处理宏，用于专门读取和打印字符，因为只针对字符，所以比通用的 scanf 和 printf 更高效。
```c
#include <stdio.h>

int main(void)
{
    char ch;
    ch = getchar(); // 读取一个字符
    
    while (ch != '\n') { // 当前读取的字符不是换行符则继续循环（控制台输入完字符后敲回车，实际上还会在末尾输入个 \n）
        if (ch == ' ') {
            putchar(ch); // 空格则正常打印
        } else {
            putchar(ch + 1); // 非空格+1后再打印，如字符 a 会+1后变成字符 b 打印（ASCII 码的下个字符）
        }

        ch = getchar(); // 读取下一个字符
    }

    putchar(ch); // 打印最后一个 \n
    printf("%c", ch);
}
```
以上代码运行后，我们在控制台输入一串字符后，字符会进入缓冲区，程序会从缓冲区一个一个的读取字符进行操作。
**注意：一个中文占用3个字符，如果我们只读取一个字符，存到 char 变量中，然后输出，则会是乱码。而如果使用循环不断读取并输出，则3个字符会作为一个中文输出。**
下面我们使用 scanf 和 printf 来验证：
```c
#include <stdio.h>
int main(void) {
    char c;
    int i = 0; // 循环计数器
    scanf("%c", &c); // 这里我们输入一个中文
    while (c != '\n') { // 循环读取控制台的输入
        i++;
        printf("%c", c); // 打印每次的输入
        scanf("%c", &c); // 读取下一个输入
    }
    printf("%d", i); // 输入一个中文，会输出3，说明一个中文循环了3次才完整输出
}
```

### ctype.h
ctype.h 包含一系列用于判断字符类别的函数。如： isalpha() 判断传入的字符是否是字母；ispunct() 判断是否是标点符号等。
具体查看：[ctype.h 标准库](https://www.runoob.com/cprogramming/c-standard-library-ctype-h.html)

# goto 语句
`goto` 语句类似 JS 中的 `break label` 语句。但是 `break label` 只能用于循环中，`goto` 语句却可以用在任何地方。所以 `goto` 语句使用更灵活，但是也更易导致问题，需要谨慎使用，最好只用在 `break label` 这样的地方，用于跳出多层嵌套循环。

示例1：
```c
// 使用 goto 语句来实现 if
if (size > 12)
    goto a;
goto b;
a:
cost = cost * 1.05;
flag = 2;
b:
bill = cost * flag;
```
```c
// 使用 if 明显更易理解
if (size > 12)
{
    cost = cost * 1.05;
    flag = 2;
}
bill = cost * flag;
```
示例2：
```c
if (ibex > 14)
    goto a;
sheds = 2;
goto b;
a:
sheds = 3;
b:
help = 2 * sheds;
```
```c
// 使用 if else 明显更好
if (ibex > 14)
    sheds = 3;
else
    sheds = 2;
help = 2 * sheds;
```
**下面是可接受的用法：**
```c
while (funct > 0)
{
    for (i = 1; i <= 100; i++)
    {
        for (j = 1; j <= 50; j++)
        {
            其他语句 
            if (问题) 
                goto help; // 嵌套循环中跳转到 help 位置
            其他语句
        }
        其他语句
    }
    其他语句
}
其他语句 
help: 语句 // 会直接跳转到这里继续执行
```

# 字符输入输出和输入验证
C 语言 stdio.h 标准库中包含一些标准的 IO 函数，它们可以在不同的系统中运行，如 Windows, Linux, Mac OS。但是一些特殊的硬件等也会实现并提供自身的 IO 函数，可能需要通过引入其头文件来使用。

### 缓冲区
无缓冲输入：当使用 scanf, getchar 这样的函数时，如果用户在控制台每输入一个字符就被程序接收并立即执行，比如我们要将输入的内容进行输入，就可能出现控制台显示为：HHeelloo。这就是无缓冲输入的表现。
缓冲输入：用户输入的字符被收集并存储在一个被称为缓冲区（buffer）的临时存储区，按下 Enter 键后，程序才可使用用户输入的字符。
![图 1](assets/1679282142322.png)  

为什么要有缓冲区？首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下 Enter 键时， 传输的是正确的输入。

虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中， 你希望按下一个键就执行相应的指令。因此，缓冲输入和无缓冲输入都有用武之地。

缓冲分为两类：完全缓冲 I/O 和行缓冲 I/O。完全缓冲输入指的是当缓冲区被填满时 才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是512字节和4096字节。行缓冲 I/O 指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下 Enter 键后才刷新缓冲区。

### 文件结尾
读取文件的时候如何判断文件达到了末尾？
第一种方法是使用 ctrl+Z 字符来作为结尾标记，当读到 ctrl+Z 即 `^Z` 时便到了末尾，但是这种方法也说明文件中不能人为输入 `^Z`，否则程序读到这里就终止读取了。
第二种方法是使用存储文件大小的信息。如果文件有3000字节，程序在读到3000字节时便达到文件的末尾。现在大部分操作系统都使用这种方式，这种方式也就可以在文件中人为写入 `^Z` 字符。
无论操作系统实际使用何种方法检测文件结尾，在C语言中，用 getchar 或 scanf 读取文件检测到文件结尾时将返回一个特殊的值，即 EOF（end of file 的缩写）。通常，EOF 定义在 stdio.h 文件中：
```c
#define EOF (-1)
```
为什么是-1？因为如果是正整数则可能是某个字符的 ASCII 编码，而-1不是 ASCII 码。可能某些系统返回的不是-1，而是-2或其它值，所以我们使用 EOF 常量名来判断就不会出错。
```c
while ((ch = getchar()) != EOF) // 使用 EOF 而不是-1
```

### 重定向输入
在运行一个 C 语言编译后的程序的时候，假设这个程序像之前的功能一样读取键盘输入并输出。我们在控制台使用 `./test` 来执行这个编译后的程序时，可以使用重定向来讲输入重定向到一个文件，而不是通过键盘输入。只需要像这样
`./test < ../test.c`
就能将源代码 test.c 文件作为输入，控制台中就会打印出 test.c 的内容。

### 重定向输出
使用 > 可以将输出进行重定向，从而写入某个文件而不是通过显示器作为输出设备。
`./test > ./test.txt`
这样就能将控制台中的输入写入 test.txt 文件中了（没有 test.txt 或创建文件，有则会覆盖内容）。

### 组合重定向
将两个符号组合使用就能实现复制功能：
`./test < ../test.c > ./test.c`
（测试时发现输出文件末尾多了两个乱码字符，不知道是为什么？）
UNIX、Linux 或 Windows/DOS 还有 `>>` 运算符，该运算符可以把数据添加到现有文件的末尾，而 `|` 运算符能把一个文件的输出连接到另一个文件的输入。

### 输入流和数字
使用 scanf 读取控制台的输入，C 语言会将控制台的输入内容作为字节流来处理。
当我们在控制台输入42，scanf 使用不同的转换说明会产生怎样的效果呢？
如果在 scanf() 函数中使用 %c 转换说明，它只会读取字符4并将其存储在 char 类型的变量中。如果使用 %s 转换说明，它会读取字符4和字符2这两个字符，并将其存储在字符数组中。如果使用 %d 转换说明，scanf() 同样会读取两个字符，但是随后会计算出它们对应的整数值：4×10+2，即42，然后将表示该整数的二进制数存储在 int 类型的变量中。如果使用 %f 转换说明，scanf() 也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示法表示该值，并将结果存储在 float 类型的变量中。
也就是 scanf 在使用不同的转换说明时，内部会针对读取到的字节流用不同的算法进行处理后赋值给变量。

# 编写头文件
我们可以使用 .h 为后缀的文件来编写自己的头文件，如 name.h 。使用头文件则是使用 `#include "name.h"` 双引号的形式引入自己的头文件。

# &运算符
当使用函数时，如果不使用 return 返回的值来改变已有的变量，则必须通过地址才能去修改已有变量的值。
一元 `&` 运算符给出变量的存储地址。如果 `pooh` 是变量名，那么 `&pooh` 是变量的地址。可以把地址看作是变量在内存中的位置。
```c
#include <stdio.h>

int main(void)
{
    int pooh = 20;
    printf("%d\n%p", pooh, &pooh);
    return 0;
}
```
以上代码输出了变量 pooh 的值和内存地址。`%p` 是输出地址的转换说明。

# 指针
什么是指针？从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如 char 类型变量的值是字符，int 类型变量的值是整数，指针变量的值是地址。**通常会指向某段内存的首地址，而这段内存的长度就是所指定类型的长度。**
[万字长文带你从内存看指针 | C语言指针完全解析](https://zhuanlan.zhihu.com/p/298363575)

### 间接运算符（解引用运算符）
间接运算符的作用是从地址中解出它的值。
```c
// 将 c 的地址赋值给 a
a = &b;
// 将 a 地址解析出来赋值给 c
c = *a;

// 上面两句的作用等同于下面一句
c = b;
```

### 声明指针
声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道存储在指定地址上的数据类型。
```c
int * pi; // pi 是指向 int 类型变量的指针 
// * 前后都可以不带空格
char *pc; // pc 是指向 char 类型变量的指针 
float * pf, * pg; // pf、pg 都是指向 float 类型变量的指针
```
上面的 `int *pc` 可以解释为：`*pc` 是 char 类型，那么 `pc` 就不是 char 类型，而是指向 char 类型的指针。pc 的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是指针不是整数类型，比如我们不能将两个指针相乘。所以指针是一个新的类型。

下面是使用指针交换两个变量值的示例：
```c
#include <stdio.h>
void interchange(int *u, int *v);

int main(void)
{
    int x = 5, y = 10;
    printf("Originally x = %d and y = %d.\n", x, y);
    interChange(&x, &y); // 把地址发送给函数
    printf("Now x = %d and y = %d.\n", x, y);
    return 0;
}

void interChange(int *u, int *v)
{
    int temp;
    temp = *u; // temp 获得 u 所指向对象的值
    *u = *v; // 将 v 地址的值赋值给 u 地址的值
    *v = temp;
}
```
**注意：**
1. 在调用 `interChange(&x, &y)` 传入 x 和 y 的地址，这个地址是复制给函数声明 `void interChange(int *u, int *v)` 中的变量 u 和 v，而不是 *u 和 *v。变量 u 接收了 x 的地址，*u 将地址所指的内存数据解析成 int 值。
2. 当修改 *u 的值时，如 `*u = 100` 表示将 u 这个地址的值改为100。如果使用 `u = 100` 就成了将 u 指向的内存地址改为指向100这个内存地址，就不对了。（可以理解为：u 指向 x 的地址，*u 则等同于 x，我们对 *u 进行赋值，则是对变量 x 进行赋值。）
3. 当然，我们在某些情况下也可能对内存地址进行赋值，比如 `u = v`，那么此时 u 和 v 都指向了相同的内存地址，我们赋值 `*u = 100`后则 *v 也成了100，main 函数中的 y 也成了100。

# 数组
需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可以用。
```c
int main(void) {
    float candy[365]; // 内含365个 float 类型元素的数组
    char code[12]; // 内含12个 char 类型元素的数组
    int states[50]; // 内含50个 int 类型元素的数组
}
```

### 初始化数组
C 语言中使用花括号 `{ }` 来初始化数组，而不是中括号 `[ ]`。
```c
int main(void) {
    int powers[8] = {1, 2, 4, 6, 8, 16, 32, 64};

    // 使用 const 初始化数组后，数组就不能被修改了
    const int arr[10] = {1, 2, 3}
    // arr[5] = 5; // 修改 arr 会报错
}
```
上面 arr 数组在初始化时只初始化了前三位，由于类型是 int，那么后7位都默认是0。如果类型是 char，那么后7位就默认是空字符。

如果声明了数组，但是未初始化，那么数组里面的值就会很奇怪，可能是分配内存地址之前的值，属于垃圾值。但是只要初始化后，就会对此段内存地址按照声明的类型赋上默认值。
```c
#include <stdio.h>
int main(void)
{
    int arr[10]; // 未初始化，遍历输出的值是垃圾值
    // int arr[10] = {}; // 初始化了，所有值为0

    for (int i = 0; i < 10; i++) {
        printf("%d\n", arr[i]);
    }
};
```

如果不指定数组长度，那么编译器就会根据初始化值分配数组长度。
```c
#include <stdio.h>
int main(void)
{
    // 会根据初始值指定长度为10
    const int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31};
    // 因为下面要和 sizeof 的值进行比较，所以声明为 unsigned long 类型才相同
    unsigned long index;
    for (index = 0; index < sizeof days / sizeof days[0]; index++) {
        printf("Month %2lu has %d days.\n", index + 1, days[index]);
    }
    return 0;
}
```
**上面代码中通过 sizeof 计算出了数组的长度。sizeof 运算符给出它的运算对象的大小（以字节为单位）。所以 `sizeof days` 是整个数组的大小（以字节为单位），`sizeof days[0]` 是数组中一个元素的大小（以字节为单位）。整个数组的大小除以单个元素的大小就是数组元素的个数。**

### 指定初始化器（C99）
置顶初始化器是 C99 新增的语法糖，可以初始化数组中后面的元素，而不用写前面的。
```c
int arr[6] = {0, 0, 0, 0, 0, 212}; // 传统的语法
int arr[6] = {[5] = 212}; // 把 arr[5] 初始化为212

int arr[6] = {};
arr[5] = 212; // 这样也可以

/*
* 索引2和3值为0
* 30会赋值给索引5
* 29会修改索引1，即索引1的28会改为29
*/
int days[12] = { 31, 28, [4] = 31, 30, 31, [1] = 29 };
```

**注意：C 不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋值。只能使用循环一个个赋值。**
```c
#include <stdio.h>
#define SIZE 5
int main(void)
{
    int oxen[SIZE] = {5, 3, 2, 8}; // 初始化没问题
    int yaks[SIZE];
    // 不允许将一个数组赋值给另一个数组
    yaks = oxen;
    // 数组下标越界，yaks 长度是5，而 yarks[5] 是给第6个元素赋值
    yaks[SIZE] = oxen[SIZE];
    // 不起作用
    yaks = {5, 3, 2, 8};
}
```

### 数组边界
C 语言中数组是有长度的，对数组外的索引进行取值/赋值操作叫做数组越界操作。当数组越界时编译器不会检查下标使用是否得当（有些编译器会警告但是继续执行），所以一定要小心数组越界问题。在C标准中，使用越界下标的结果是未定义的，不同的编译器可能给出不同的结果。
如果给越界的下标赋值，越界的下标可能指向的是另一个变量的内存地址，这时就会修改到另一个变量的值。所以越界操作是非常危险的。

### 变长数组
C99 之前创建数组，中括号中只能使用整型常量，不能使用变量。sizeof 表达式被视为整型常量。const 声明的变量也不行。
C99 之后可以使用变量声明数组的长度，这种数组称为变长数组。
但是在声明变长数组时不能进行初始化。若初始化，编译器会报错。
```c
int main(void)
{
    int n = 5;
    int m = 8;
    const int o = 7;
    float a1[5];               // 可以
    float a2[5 * 2 + 1];       // 可以
    float a3[sizeof(int) + 1]; // 可以
    float a4[-4];              // 不可以，数组大小必须大于0
    float a5[0];               // 不可以，数组大小必须大于0
    float a6[2.5];             // 不可以，数组大小必须是整数
    float a7[(int)2.5];        // 可以，已被强制转换为整型常量
    float a8[n];               // 变长数组，C99之前不允许
    float a9[m];               // 变长数组，C99之前不允许
    float a10[o];               // 变长数组，const 声明的也是变量
}
```

### 多维数组
声明多维数组使用多个中括号即可。
```c
float rain[5][12]; // 内含5个数组元素的数组，每个数组元素内含12个float类型的元素
```
在计算机内部，这样的数组是按顺序存储的，从第1个内含12个元素的数组开始，然后是第2个内含12个元素的数组，以此类推。
以下是对多维数组的初始化：
```c
const float rain[5][12] = {
    {4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6}, 
    {8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.3}, 
    {9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.1, 8.4}, 
    {7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 6.2}, 
    {7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 5.2}
};
```
初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数 值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。

### 指针和数组
首先需要知道**数组的变量名是数组首元素的地址**。所以：
```c
int main(void)
{
    int arr[10] = {6, 9};
    // 相等，输出1表示 true
    printf("%d\n", arr == &arr[0]);
    // 输出第一个元素6
    printf("%d\n", *arr);
}
```
由此也就能知道什么不能将一个数组赋值给另一个数组了，数组变量是个地址，地址是个常量，不能进行赋值操作。

由于数组变量是个地址，那么可以将其赋值给指针。赋值给指针后，对指针进行+1操作会怎样呢？
```c
#include <stdio.h>
#define SIZE 4
int main(void)
{
    short index;
    double bills[SIZE];
    double *ptf;
    ptf = bills; // 把数组地址赋给指针
    for (index = 0; index < SIZE; index++) {
        // ptf + index 对指针进行+操作
        printf("pointers + %d: %10p\n", index, ptf + index);
    }
}

这是输出结果：
pointers + 0: 0x7ffee6d59640
pointers + 1: 0x7ffee6d59648
pointers + 2: 0x7ffee6d59650
pointers + 3: 0x7ffee6d59658
```
我们打印出指针的地址，发现每+1则地址+8，这是因为 double 类型占8个字节，所以指针+1地址就+8，如果是其它类型那么就是其对应所占字节数。

注：
1. 上面的例子中指针+1，地址+8也就正好指向数组第2个元素的地址。如果指针声明的类型不对，那么就不会指向第二个元素了。
2. 数组也是使用的连续内存，每个元素占用的内存空间就是其类型所占用的字节数。下一个数组元素的开始地址会紧接上个元素的结束地址。
3. 这也是为什么必须声明指针的类型的原因之一。因为只知道地址还不够，计算机还需要知道存储的数据需要多少字节。指针指向了一个内存地址，而类型决定了从这个内存地址开始取多少个字节的数据出来转换成这个类型的值。

由此可见，类型是多么的重要。这也是 C 语言性能高的原因之一。

### 函数、数组和指针
假设我们要编写一个接收数组进行操作的函数，那么函数的形参该怎么写呢？数组名是该数组首元素的地址，所以函数接收一个数组即是接收一个地址，形参就该是一个指针：
```c
int sum(int *arr);

int sum(int *arr) // 相应的函数定义
{
    int i;
    int total = 0;
    for (i = 0; i < 10; i++) // 假设数组有10个元素
        total += arr[i];      // arr[i] 与 *(arr + i) 相同
    return total;
}
```
由于函数参数中使用指针的写法来接收数组，我们不能容易的知道这个函数是接收的数组，所以函数的形参新增了个语法糖来表示接收数组的指针：
```c
int sum(int arr[]);

int sum(int arr[]) // 相应的函数定义
{
    ...
}
```
由于函数原型可以省略参数名，所以下面4种原型都是等价的：
```c
int sum(int *arr, int n);
int sum(int *, int);
int sum(int arr[], int n);
int sum(int [], int);
```
**注意，函数中的形参接收一维数组不用指定数组长度。用指针表示法也是指向首元素地址，并不知道数组长度。**

### 数组和 sizeof
当我们使用 sizeof 获取数组所占用字节数时一个有趣的现象出现了：
```c
int main(void)
{
    int n = 10;
    int arr[10] = {};
    int *p = arr;
    printf("%zd\n", sizeof(n)); // 输出4，int 占用的字节数
    printf("%zd\n", sizeof(&n)); // 输出8，地址（指针）所占用的字节数
    printf("%zd\n", sizeof(arr)); // 输出40，10个int元素数组所占用的字节数
    printf("%zd\n", sizeof(p)); // 输出8，地址（指针）所占用的字节数
    printf("%zd\n", sizeof(*p)); // 输出4，int 所占用的字节数
}
```
可以看出，只有在 sizeof(arr) 的时候输出了数组所占的总字节数，而当把 arr 赋值给指针后就只能获取到指针所占字节数，再也不能通过 p 拿到数组 arr 所占的总字节数了。
这就意味着如果我们把数组通过指针形式传给函数后，函数内部也拿不到数组的总长度了。那么只能通过传参时计算出数组的长度传给函数才行。如：
```c
#include <stdio.h>
int arrayLength(int arr[], int arrSize);

int main()
{
    int b[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
    // 计算出数组长度再传入函数
    int length = sizeof(b) / sizeof(b[0]);
    arrayLength(b, length);
    return 0;
}
// 需要接收数组长度
int arrayLength(int arr[], int arrSize)
{
    printf("size of array is %d\n", arrSize);
    return 0;
}
```
另一种方式是函数接收两个指针，一个指向数组开始位置，一个指向数组结束位置（不是最后一个元素，而是最后一个元素的下个位置），对指针进行运算也能操作数组：
```c
#include <stdio.h>
#define SIZE1 1
#define SIZE2 10
int sump(int *start, int *end);
int main(void)
{
    int marbles1[SIZE1] = {10};
    int marbles2[SIZE2] = {20, 10, 5, 39, 4, 16, 19, 26, 31, 20};
    printf("%zd\n", sizeof(int));
    sump(marbles1, marbles1 + SIZE1);
    sump(marbles2, marbles2 + SIZE2);
    return 0;
}
/* 使用指针算法 */
int sump(int *start, int *end)
{
    printf("%p, %p, array size: %ld\n", start, end, end - start);
    int total = 0;
    while (start < end)
    {
        total += *start; // 把数组元素的值加起来
        start++;         // 让指针指向下一个元素
    }
    return total;
}

输出内容：
// int 类型所占字节数
4
// 数组长度为1，两个指针地址相差4，正是 int 类型的字节数。end 指针减去 start 指针结果为1，说明指针相减也和类型有关。所以也能得到数组长度
0x7ffeed528638, 0x7ffeed52863c, array size: 1
// 两个地址相减结果为 0x000000000028，即10进制的40，所以占用40个字节，长度为10
0x7ffeed528640, 0x7ffeed528668, array size: 10
```
通过传递数组和长度对进行数组进程操作的方式叫数组表示法，通过传递数组首位指针进行操作的方式叫指针表示法。数组表示法比指针表示法更易理解，指针表示法（尤其与递增运算符一起使用时）更接近机器语言，因此一些编译器在编译时能生成效率更高的代码。然而，许多程序员认为他们的主要任务是确保代码正确、逻辑清晰，而代码优化应该留给编译器去做。

### 保护数组中的数据
当我们编写处理数组的函数时，由于传的是指针，通过指针修改元素的值就会改变数组的数据。但是有时不想改变原数组该怎么办呢？
做法是对形参使用 const。在函数原型和函数定义中都使用 const 声明形参，这样在对数组指针进行修改时编译器会报错。
```c
int sum(const int arr[], int n); /* 函数原型 */
int sum(const int arr[], int n)  /* 函数定义 */
{
    arr[0]++; // 这样写编译器就会报错
    ...
}
```
也能看出 C 语言中使用 const 声明的数组，对其中的元素进行修改都不行，在 JS 中这是可以的。

### const 的其它内容
1. const 声明的数组，不能修改数组元素的值。
2. const 声明的指针，不能用于改变值。
```c
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double *pd = rates; // 指针指向数组，值就是首元素的值
*pd = 13.14; // 不能这样修改，因为指针类型是 const double
pd[2] = 52.12; // 这样也不行
rates[0] = 99.99; // 可以，因为 rates 未被 const 限定
pd++; // 这样反而可以，因为 const double 是将 *pd 即解引用的值声明为 const，但是 pd 这个指针自身不是 const 的

const double locked[4] = {0.08, 0.075, 0.0725, 0.07};
double *pnc = rates; // 可以。非 const 数组赋值给非 const 指针
pnc = locked; // 不行。const 数组不能赋值给非 const 指针，如果能赋值，则可以通过指针修改 const 的数据了
```
另外，如果函数接收的数组形参不是 const 的，但是我们传了个 const 的数组给它，此时编译器可能给出警告但不会终止运行，这时就会导致风险。这种情况通过指针对 const 数组进行操作 C 标准中未定义，根据编译器自己决定。

还可以通过 const 声明不能指向别处的指针：
```c
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
double * const pc = rates; // pc指向数组的开始。const 在 pc 之前
pc = &rates[2]; // 不允许，因为该指针不能指向别处
*pc = 92.99; // 没问题 -- 更改rates[0]的值
```
此时是指针被限制为 const，而不是指针解引用的值。

通过以上两种情况可以得出，在创建指针时还可以使用 const 两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值：
```c
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double * const pc = rates; // 两个 const 将指针和解引用值都限制为不可修改
pc = &rates[2]; // 不允许
*pc = 92.99;    // 不允许
```

### 指针和多维数组
假设我们有个数组：
```c
int zippo[4][2];
```
那么有以下几个要点需要记住：
* 因为`zippo`是数组首元素的地址，所以`zippo`的值和`&zippo[0]`的值相同。而`zippo[0]`本身是一个内含两个整数的数组，所以`zippo[0]`的值和它首元素（一个整数）的地址（即`&zippo[0][0]`的值）相同。简而言之，`zippo[0]`是一个占用一个 int 大小对象的地址，而`zippo`是一个占用**两个** int 大小对象的地址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以`zippo`和`zippo[0]`的值相同。
* 给指针或地址加1，其值会增加对应类型大小的数值。在这方面，`zippo`和`zippo[0]`不同，因为`zippo`指向的对象占用了两个 int 大小，而`zippo[0]`指向的对象只占用一个 int 大小。因此，`zippo + 1`和`zippo[0] + 1`的值不同。`zippo + 1`会将指针指向一维数组中第二个元素，而数组中每个元素也是个数组，每个数组是两个 int，所以占8字节，`zippo + 1`就会往后移动8个字节来指向第二个元素。
* 解引用一个指针（在指针前使用`*`运算符）或在数组名后使用带下标的`[]`运算符， 得到引用对象代表的值。因为`zippo[0]`是该数组首元素（`zippo[0][0]`）的地址，所以`*(zippo[0])`表示存储在`zippo[0][0]`上的值（即一个 int 类型的值）。与此类似，`*zippo`代表该数组首元素（`zippo[0]`）的值，但是`zippo[0]`本身是一个int类型值的地址。该值的地址是`&zippo[0][0]`，所以`*zippo`就是`&zippo[0][0]`。对两个表达式应用解引用运算符表明，`**zippo`与`*&zippo[0][0]`等价，这相当于`zippo[0][0]`，即一个 int 类型的值。简而言之，`zippo`是地址的地址，必须解引用两次才能获得原始值。地址的地址或指针的指针是就是双重间接（double indirection）的例子。**即`zippo`指向数组首元素的地址，`*zippo`是数组首元素的值（同`zippo[0]`），数组首元素的值又是第二维数组中首元素的地址，对其解引用即`**zippo`（同`*zippo[0]`）就能拿到第二维数组首元素的值。**

### 指向多维数组的指针
使用 `int *pz;` 可以声明一个指针，指向一个数组元素是 int 类型的一维数组，那么如何声明一个指针指向一个二维数组呢？二维数组我们应该知道第二维数组的元素个数，所以可以这样声明：
```c
int (*pz)[2]; // pz 指向一个第二维是两个 int 类型的二维数组
```
我们知道如果 pz 指向一维数组，那么`*pz`就是数组中首元素的值。所以`(*pz)[2]`就表明数组中首元素的值是个拥有两个元素的数组，前面的 int 说明两个元素是 int 类型。

注意`[]`优先级高于`*`所以必须加`()`，如果不加则是：
```c
int *px[2]; // px 是含有两个元素的数组，每个元素是个指向 int 类型的指针
```

其实`int (*pz)[2]`的本质是指向一个地址，而这个地址解引用后是个具有两个 int 元素的数组就行。将一个二维数组赋值给它时，（数组赋值给指针是将首元素的地址赋值，并且类型匹配）它会指向数组的首元素，而首元素也是包含两个 int 元素的数组，所以是匹配的，所以能将它作为二维数组的指针来使用：
```c
int arr1[3][2] = {{1, 2}, {3, 4}, {5, 6}};
int (*p1)[2] = arr1; // p1 指向 arr1 的第一个元素 arr1[0]
p1++; // p1 的类型是有两个 int 元素的数组，所以会+8后指向第二个元素

int arr2[2] = {1, 2};
int (*p2)[2] = &arr2; // p2 指向一个具有两个 int 元素的地址
```
**由此可以看出，我们使用指针来操作数组就是要让指针的类型和数组元素类型匹配上，当操作指针时就能正确的对数组进行操作。**

### 指针的兼容性
指针之间的赋值比普通类型的赋值要更严格，如 int 类型赋值给 double 类型，会进行隐式转换；但是指针的赋值如果类型不匹配则会直接报错。
```c
int n = 5;
double x;
int *p1 = &n;
double *pd = &x;
x = n;   // 隐式类型转换
pd = p1; // 编译时错误
```
在二维数组中，即使第二维类型相同，个数不同，赋值时也会报错。

### 指向指针的指针
可以声明一个指针指向另一个指针，这就是指向指针的指针：
```c
int main(void)
{
    int n = 10;
    int *p;
    int **pp; // 指向指针的指针，使用两个 *
    pp = &p;
    printf("变量 n 的内存地址：%p\n", &n);
    printf("未赋值的 p 指向的内存地址：%p\n", p);
    p = &n;
    printf("变量 n 的地址赋值给 p 后：%p\n", p);
    printf("p 自己的内存地址：%p\n", &p);
    printf("pp 指向的内存地址：%p\n", pp);
    printf("p 解引用的值：%d\n", *p);
    printf("pp 解引用的值：%p\n", *pp);
    printf("pp 双重解引用的值：%d\n", **pp);
}

输出结果：
变量 n 的内存地址：0x7ffee786964c
未赋值的 p 指向的内存地址：0x7ffee7869660
变量 n 的地址赋值给 p 后：0x7ffee786964c
p 自己的内存地址：0x7ffee7869640
pp 指向的内存地址：0x7ffee7869640
p 解引用的值：10
pp 解引用的值：0x7ffee786964c
pp 双重解引用的值：10
```
可以看出：
1. 在将变量 n 的地址赋值给 p 之前和之后，p 指向的地址变了。赋值后 p 就指向变量 n 的地址
2. 指针也是个变量，也有自己的内存地址，p 的内存地址就是 0x7ffee7869640
3. pp 指向 p，所以 pp 的值是 p 的地址 0x7ffee7869640
4. 对 pp 解引用，那么 `*pp` 的值就该是 p 的值，而不是 p 的地址，即 p 指向的内存地址 0x7ffee786964c
5. 对 pp 双重解引用 `**pp` 就是对 p 指向的内存地址再次解引用，拿到这个内存地址的实际值 10

### 函数和多维数组
多维数组的函数形参可以这样声明：
```c
// 指针表示法
void somefunction(int (*pt)[4]);
// 数组表示法
void somefunction(int pt[][4]);
```
注意，第1个方括号是空的。**空的方括**号表明 pt 是一个指针。
编译器会把数组表示法转换成指针表示法。例如，编译器会把`arr[1]`转 换成`arr+1`。编译器对`arr+1`求值，需要知道 arr 所指向的对象大小，所以声明数组时需要指定类型。

也可以在第1对方括号中写上大小，如下所示，但是编译器会忽略该值：
```c
int sum2(int arr[3][4], int rows); // 有效声明，但是3将被忽略
```

下面是更多声明二维数组的方式：
```c
typedef int arr4[4];              // arr4是一个内含 4 个 int 的数组
// 使用 typedef 定义二维数组类型
typedef arr4 arr3x4[3];           // arr3x4 是一个内含3个 arr4 的数组
int sum2(arr3x4 arr, int rows);    // 与下面的声明相同
int sum2(int arr[3][4], int rows); // 与下面的声明相同
int sum2(int arr[][4], int rows);  // 标准形式
```

一般而言，声明一个指向 N 维数组的指针时，只能省略最左边方括号中的值：
```c
int sum4d(int arr[][12][20][30], int rows);
```
因为第1对方括号只用于表明这是一个指针，而其他的方括号则用于描述指针所指向数据对象的类型。下面的声明与该声明等价：
```c
int sum4d(int (*arr)[12][20][30], int rows); // arr 是一个指针
```

### 变长数组（VLA）
C99 新增了变长数组（variable-length array，VLA），允许使用变量表示数组的维度。如下所示：
```c
int quarters = 4;
int regions = 5;
double sales[regions][quarters]; // 一个变长数组（VLA）
```
注意，变长数组不能改变大小。变长数组中的“变”不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。这里的“变”指的是：在创建数组时，可以使用变量指定数组的维度。

#### 声明接收变长数组的函数
首先，要声明一个带二维变长数组参数的函数，如下所示：
```c
int sum2d(int rows, int cols, int arr[rows][cols]); // arr 是一个变长数组（VLA）
```
注意前两个形参（ rows 和 cols）用作第3个形参二维数组 arr 的两个维度。因为 arr 的声 明要使用 rows 和 cols，所以在形参列表中必须在声明 arr 之前先声明这两个形参。**因此，下面的原型是错误的：**
```c
int sum2d(int arr[rows][cols], int rows, int cols); // 无效的顺序
```
其次，该函数的定义如下：
```c
int sum2d(int rows, int cols, int arr[rows][cols])
{
    int r;
    int c;
    int total = 0;
    for (r = 0; r < rows; r++)
        for (c = 0; c < cols; c++)
            total += arr[r][c];
    return total;
}
```
以变长数组作为形参的函数既可处理传统 C 数组，也可处理变长数组。所以变长数组更灵活，但是需要编译器支持。
变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大小。普通 C 数组都是静态内存分配，即在编译时确定数组的大小。由于数组大小是常量，所以编译器在编译时就知道了。

### 复合字面量
C99新增了复合字面量（compound literal）。字面量是除符号常量外的常量。例如，5是int类型字面量，81.3是double类型的字面量，'Y'是char类型的字面量，"elephant"是字符串字面量。发布C99标准的委员会认为，如果有代表数组和结构内容的复合字面量，在编程时会更方便。
复合字面量的作用就是不需要先声明一个数组再使用，可以直接赋值给指针、作为实参赋值给形参等。

以下是数组的复合字面量写法：
```c
(int[2]){10, 20} // 复合字面量
```
初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大小，编译器会自动计算数组当前的元素个数：
```c
(int[]){50, 20, 90} // 内含3个元素的复合字面量
```

使用复合字面量：
```c
// 将复合字面量赋值给数组
int * pt1;
pt1 = (int[2]){10, 20};

// 将复合字面量作为实参传值
int sum(const int ar[], int n);
...
int total;
total = sum((int[]){4, 4, 4, 5, 5, 5}, 6);
```



# 指针操作
C提供了一些基本的指针操作，下面的程序示例中演示了8种不同的操作。
```c
#include <stdio.h>
int main(void)
{
    int arr[5] = {100, 200, 300, 400, 500};
    int *ptr1, *ptr2, *ptr3;
    // 把地址赋给指针
    ptr1 = arr;
    ptr2 = &arr[2];
    // 解引用指针，以及获得指针的地址
    printf("pointer value, dereferenced pointer, pointer address:\n");
    printf("ptr1 = %p, *ptr1 =%d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);
    // 指针加法
    ptr3 = ptr1 + 4;
    printf("\nadding an int to a pointer:\n");
    printf("ptr1 + 4 = %p, *(ptr1 + 4) = %d\n", ptr1 + 4, *(ptr1 + 4));
    // 递增指针
    ptr1++;
    printf("\nvalues after ptr1++:\n");
    printf("ptr1 = %p, *ptr1 =%d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);
    // 递减指针
    ptr2--;
    printf("\nvalues after --ptr2:\n");
    printf("ptr2 = %p, *ptr2 = %d, &ptr2 = %p\n", ptr2, *ptr2, &ptr2);
    // 恢复为初始值
    --ptr1;
    ++ptr2;
    printf("\nPointers reset to original values:\n");
    printf("ptr1 = %p, ptr2 = %p\n", ptr1, ptr2);
    // 一个指针减去另一个指针
    printf("\nsubtracting one pointer from another:\n");
    printf("ptr2 = %p, ptr1 = %p, ptr2 - ptr1 = %td\n", ptr2, ptr1, ptr2 - ptr1);
    // 一个指针减去一个整数
    printf("\nsubtracting an int from a pointer:\n");
    printf("ptr3 = %p, ptr3 - 2 = %p\n", ptr3, ptr3 - 2);
    return 0;
}
```
除了这些操作，还可以使用关系运 算符来比较指针。
* 赋值：可以把地址赋给指针。例如，用数组名、带地址运算符`&`的变量名、另一个指针进行赋值。
* 解引用：`*`运算符给出指针指向地址上存储的值。
* 取址：和所有变量一样，指针变量也有自己的地址和值。对指针而言，`&`运算符给出指针本身的地址。
* 指针与整数相加：可以使用`+`运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。
* 递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。
* 指针减去一个整数：可以使用`-`运算符从一个指针中减去一个整数。指针必须是第1个运算对象，整数是第2个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。
* 递减指针：当然，除了递增指针还可以递减指针。
* 指针求差：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。
* 比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。

### 不要解引用未初始化的指针
```c
int *pt; // 未初始化的指针
*pt = 5; // 严重的错误
```
pt 未被初始化，其值是一个随机值，所以不知道5将存储在何处。这可能不会出什么错，也可能会擦写数据或代码，或者导致程序崩溃。切记：创建一个指针时，系统只分配了存储指针本身的内存，并未分配存储数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。


# 字符串和字符串函数
字符串是以空字符`\0`结尾的 char 类型数组。因此，可以把数组和指针的知识应用于字符串。不过，由于字符串太常用了，因此 C 语言提供了大量的用于处理字符串的数组。

### puts
puts 方法类似 printf，专门用于打印字符串，并且会在打印字符串的末尾加上换行符。
```c
#include <stdio.h>
#define MSG "字符串测试0" // 字符串常量

int main(void)
{
    char s[20] = "字符串测试1"; // 字符串数组
    char *p = "字符串测试2";    // 使用指针不用指定长度
    puts(MSG);
    puts(s);
    puts(p);
    puts("字符串测试3"); // 字符串字面量
}
```

### 字符串字面量
双引号括起来的内容都是字符串字面量，也叫做字符串常量。
从 ANSI C 标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C 会将其视为串联起来的字符串字面量。例如：
```c
// greeting1 和 greeting2 是一样的
char greeting1[50] = "Hello, and"" how are" " you" 
" today!";
char greeting2[50] = "Hello, and how are you today!";
puts(greeting1);
puts(greeting2);
```

打印字符串中的双引号需要使用转义符 `\`：
```c
puts("\"Run, Spot, run!\" exclaimed Dick.\n");
```

字符串常量属于静态存储类别（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被存储一次，在整个程序的生命期内存在，即使函数被调用多次。

用双引号括起来的内容被视为指向该字符串存储位置的指针。这类似于把数组名作为指向该数组位置的指针。
```c
/* 
 * 这里将打印出 s，因为字符串常量可以看做是 char 类型的数组，会有个指针指向它的头部，
 * 即第一个字符，所以对指针解引用就会得到第一个字符。
 */
printf("%c\n", *"space farers");
// 等同于
char *p = "space farers";
printf("%c\n", *p);
```

### 字符串数组
使用数组的方式来存储字符串：
```c
// 指定了数组的长度，数组长度要大于字符串长度+1
// 数组中所有未被使用的元素都被自动初始化为0（这里的0指的是 char 形式的空字符\0，不是数字字符0）
const char s1[40] = "If you can't think of anything, fake it.";
// 不指定长度则编译器会自动计算字符串的长度，将数组初始化为字符串的长度+1
const char s2[] = "If you can't think of anything, fake it.";
printf("%zd\n", sizeof(s2)); // 打印41，字符串长度为40，加了位\0
```
**字符串处理函数通常通过查找字符串末尾的空字符确定字符串在何处结束。**

字符数组名和其他数组名一样，是该数组首元素的地址。因此：
```c
char car[10] = "Tata";
// 以下表达式都为真
car == &car[0]; // 和首元素的地址相等
*car == 'T'; // 解引用是第一个字符
*(car+1) == car[1] == 'a'; // 指针+1得到第二个字符
```

### 数组和指针
#### 1. 使用数组的情况：
```c
char arr1[] = "hello";
```
数组形式（arr1[]）在计算机的内存中分配为一个内含5个元素的数组（每个元素对应一个字符，还加上一个末尾的空字符`\0`），每个元素被初始化为字符串字面量对应的字符。字符串在编译后存储在静态存储区（static memory）中。但是，程序在开始运行时才会为该数组分配内存。此时，才将字符串拷贝到数组中。注意，此时字符串有两个副本。一个是在静态内存中的字符串字面量，另一个是存储在 arr1 数组中的字符串。
此后，**编译器便把数组名 arr1 识别为该数组首元素地址（&arr1[0]）的别名**。在数组形式中，arr1 是地址常量。不能更改 arr1，如果改变了 arr1，则意味着改变了数组的存储位置（即地址）。**即不能对 arr1 进行赋值，如：`++arr1`。这样操作会将首元素的地址修改为第二个元素的地址，从而导致程序出错。**

#### 2. 使用指针的情况
```c
char *pt1 = "hello";
```
一开始，字符串也是存储在静态存储区。一旦开始执行程序，它会为指针变量 pt1 留出一个存储位置（指针变量自身所占的空间，用来存储赋给它的地址），然后把字符串的地址存储在指针变量中（直接将静态存储区的地址赋值给指针）。该变量最初指向该字符串的首字符，但是它的值可以改变。因此，可以使用递增运算符。例如，`++pt1` 将指向第2个字符 e（也就是将指针变量的值赋值成了第二个字符的地址）。
另外字符串字面量被视为 const 数据，所以我们不能通过 pt1 来修改字符串。而用数组方式声明的字符串，每个字符是作为一个数组的元素存储的，所以可以修改。

**注意以下示例**
```c
#define MSG "I'm special"
#include <stdio.h>

int main()
{
    char arr[] = MSG;
    const char *pt = MSG;
    printf("address of MSG: %p\n", MSG);
    printf("address of \"I'm special\": %p \n", "I'm special");
    printf("address ar: %p\n", ar);
    printf("address pt: %p\n", pt);
    printf("address of \"I'm special\": %p \n", "I'm special");
    return 0;
}

输出：
address of MSG: 0x103c6df50 // 常量 MSG 的地址，MSG 的值是字符串字面量 "I'm special"
// "I'm special" 字符串字面量的地址
// 这里就能看出编译后，相同的字符串不会存储多份，都是存储在同一个地址
address of "I'm special": 0x103c6df50
address arr: 0x7ffeebf9265c // 字符串数组指向的地址，字符串拷贝了一份，所以地址变了
address pt: 0x103c6df50 // 指针指向的地址，直接指向字符串的静态存储区地址
address of "I'm special": 0x103c6df50 // 多次使用相同字符串也是同一个地址
```
从示例中我们可以得出结论：
1. 数组指向的地址与其它的不同，因为指向的是字符串拷贝成为数组的地址。
2. 指针指向的地址与字符串字面量相同，因为指针直接指向了字符串字面量的地址，即静态存储区地址。
3. 相同的字符串多次出现，在编译阶段会进行优化，存储为一份。（某些编译器可能不会优化，存储为多份）
4. 编译器使用不同的位数表示两种内存地址（静态存储区和动态内存）。

#### 关于内存分区
C 语言内存分区包括以下几个部分：
* 栈（Stack）：存储函数的参数值、局部变量的值等，由编译器自动分配和释放。
* 堆（Heap）：动态分配内存，需要手动管理内存的分配和释放，一般由程序员通过调用`malloc()、calloc()、realloc()`等函数来使用。
* 数据区（Data segment）：包括全局变量和静态变量，程序运行前分配内存，在程序运行期间一直存在，直到程序结束才会被释放。（上面提到的静态存储区也就是数据区）
* 代码区（Code segment）：存放程序的执行代码。

**字符串常量是存储在数据区（Data segment）中的。在程序编译时，编译器会将所有字符串常量放在数据区，并分配固定的内存空间来存储它们。**

所以，字符串使用数组和指针声明的操作有以下区别：
```c
// 数组没用 const，但是数组 arr 是常量
char arr[] = "hello";
// 指针使用了 const，但是指针 p 是变量，*p 才是常量
// 使用 const 声明能避免对指针解引用赋值
const char *p = "world";

不可以：
arr = p; // 不能对 arr 进行赋值
*p = 'x'; // 不能修改字符串字面量中的字符，即时上面没使用 const 也不能改
p[1] = 'x'; // 同上

可以：
arr[1] = 'x'; // 字符串字面量被拷贝到了动态内存中，所以可以修改
p++; // 指向下一个字符
```
如果需要修改字符串的内容，那么就必须声明为数组；只是将字符串作为常量使用，用于遍历等用指针更好，因为指针的方式会节省很多内存，尤其是在字符串数组中。
```c
// 数组的方式由于字符串要拷贝到动态内存中成为数组，所以需要指定字符串的长度，而且要以最长那个为准
char arr[3][20] = {
    "1234567890123456789",
    "12345",
    "1"
};

// 指针的方式则只需指定数组的长度即可
const char *p[3] = {
    "1234567890123456789",
    "12345",
    "1"
};
```

### 字符串输入
**如果想把一个字符串读入程序，首先必须预留存储该字符串的空间，然后用输入函数获取该字符串。**

#### 分配空间
当要接收字符串输入时，需要先声明变量，并指定能存储的字符串长度。

以下使用指针的形式就**不能**用来接收用户输入的字符串，因为指针指向个地址，用户输入的字符串并不知道地址在哪，可能会随机分配个地址覆盖了其它数据，导致程序出错。
```c
char *name; // 不知道指向哪里的指针
scanf("%s", name);
```
所以应该使用数组的形式来接收用户输入的字符串，就能提前分配一块地址用来存储用户输入的字符串了。
```c
char name[21]; // 创建了个21个空字符的数组
scanf("%s", name);
```

#### gets() 函数（不建议使用）
gets 函数可以接收用户输入的字符串，不过它的问题在于不会验证输入字符串的长度就赋值给字符串变量，从而可能导致缓冲区溢出（buffer overflow）。
```c
char words[11];
puts("Enter a string, please.");
gets(words); // 典型用法
printf("%s\n", words);
```
如果输入的字符串超过10位就可能导致程序异常。

#### fgets() 函数
fgets() 函数通过第2个参数限制读入的字符数来解决溢出的问题。该函数专门设计用于**处理文件输入**，所以一般情况下可能不太好用（会保留换行符，对于控制台的输入不友好）。fgets() 和 gets() 的区别如下。

* fgets() 函数的第2个参数指明了读入字符的最大数量。如果该参数的值是n，那么 fgets() 将读入 n-1 个字符，或者读到遇到的第一个换行符为止。
* 如果 fgets() 读到一个换行符，会把它存储在字符串中。这点与 gets() 不同，gets() 会丢弃换行符。
* fgets() 函数的第3个参数指明要读入的文件。如果读入从键盘输入的数据，则以 stdin（标准输入）作为参数，该标识符定义在 stdio.h 中。

fgets() 通常和 fputs() 配对使用来读写文件。
```c
#include <stdio.h>
#define STRLEN 14
int main(void)
{
    char words[STRLEN];
    puts("Enter a string, please.");
    fgets(words, STRLEN, stdin); // 接收的输入中就包含 \n

    printf("Your string twice (puts(), then fputs()):\n");
    puts(words); // puts 输出的会在末尾再加个 \n 导致多个空行
    fputs(words, stdout); // fputs 输出的不会再添加 \n
}
```

fgets() 函数返回指向 char 的指针。如果一切进行顺利，该函数**返回的地址与传入的第1个参数相同**。但是，如果函数**读到文件结尾，它将返回一个特殊的指针：空指针（null pointer）**。C 语言中用宏 NULL 来表示（如果在读入数据时出现某些错误，该函数也返回 NULL）。

#### gets_s() 函数
C11新增的 gets_s() 函数（可选）和 fgets() 类似，用一个参数限制读入的字符数。gets_s() 与 fgets() 的区别如下。

* gets_s() 只从标准输入中读取数据，所以不需要第3个参数。
* 如果 gets_s() 读到换行符，会丢弃它而不是存储它。
* 如果 gets_s() 读到最大字符数都没有读到换行符，会执行以下几步。首先把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直至读到换行符或文件结尾，然后返回空指针。接着，调用依赖实现的“处理函数”（或你选择的其他函数），可能会中止或退出程序。

gets_s() 函数很安全，但是，如果并不希望程序中止或退出，就要知道如何编写特殊的“处理函数”。另外，如果打算让程序继续运行，gets_s() 会丢弃该输入行的其余字符，无论你是否需要。

#### scanf() 函数
scanf() 函数更像是获取单词的函数，如果使用 %s 转换说明，则遇到空白字符（空行、空格、制表符或换行符）作为字符串的结束（字符串不包括空白字符）。

### 字符串输出
#### puts() 函数
puts() 函数很容易使用，只需把字符串的地址作为参数传递给它即可。puts() 函数在显示字符串时会自动在其末尾添加一个换行符。
```c
#include <stdio.h>
#define DEF "I am a #defined string."
int main(void)
{
    char str1[80] = "An array was initialized to me.";
    const char *str2 = "A pointer was initialized to me.";
    // 字符串存储在静态存储区，将字符串传给函数实际上传的是首字符的地址
    puts("I'm an argument to puts().");
    puts(DEF);
    puts(str1);
    puts(str2);
    puts(&str1[5]);
    puts(str2 + 4);
}
```
该函数在遇到空字符（`\0`）时就停止输出，所以必须确保有空字符。
```c
int main(void)
{
    char yes[] = {'W', 'O', 'W', '!', '\0'}; // 末尾有个空字符 \0
    char no[] = {'W', 'O', 'W', '!'}; // 末尾没有空字符
    puts(yes);
    puts(no); // 当打印出 WOW! 后还会继续读取内存数据打印，直到遇到 \0 为止
}
```

### 字符串函数
C 库提供了多个处理字符串的函数，ANSI C 把这些函数的原型放在 string.h 头文件中。其中最常用的函数有 strlen()、strcat()、strcmp()、strncmp()、strcpy() 和 strncpy()。

#### strlen() 函数
strlen() 函数用于统计字符串的长度。
```c
#include <stdio.h>
#include <string.h>

void fit(char *string, unsigned int size);

int main(void)
{
    char str[] = "hello world"; // 由于要修改字符串，所以使用字符串数组而不是指针
    fit(str, 8);
    puts(str); // 输出 hello wo。因为 r 被替换成了 \0，puts 读到空字符就终止了
}

// 由于我们要修改字符串，所以 char *string 没使用 const 声明
void fit(char *string, unsigned int size)
{
    // 使用 strlen 判断字符串长度是否大于指定的长度
    if (strlen(string) > size)
    {
        string[size] = '\0'; // 将字符串的第 size 位改为空字符
    }
}
```

#### strcat() 函数
strcat()（用于拼接字符串）函数接受两个字符串作为参数。该函数把第2个字符串的备份附加在第1个字符串末尾，并把拼接后形成的新字符串作为第1个字符串，第2个字符串不变。所以，要注意拼接后的字符串长度不能大于第一个参数字符串数组的最大长度。
```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    // 这里必须指定长度，而且要大于拼接后的字符串总长度。如果指定的长度小于拼接后的长度，则会报错
    char str1[40] = "hello world";
    char str2[] = "aaaaaaaaa";
    // 将第二个字符串拼接到第一个字符串末尾
    strcat(str1, str2);
    puts(str1);
}
```

#### strncat() 函数
strcat() 函数无法检查第1个数组是否能容纳第2个字符串。使用 strncat() 函数可以指定第三个参数，第三个参数是个数值类型，表示最大添加的字符数。
```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    // 这里必须指定长度，而且要大于拼接后的字符串总长度。如果指定的长度小于拼接后的长度，则会报错
    char str1[40] = "hello world";
    char str2[] = "abcdefg";
    // 只会添加 str2 的两个字符即 ab 到 str1 中
    strncat(str1, str2, 2);
    puts(str1);
}

```

#### strcmp() 函数
该函数通过比较运算符来比较字符串，就像比较数字一样。如果两个字符串参数相同，该函数就返回0，否则返回非零值。
```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char str1[40] = "hello world";
    char str2[] = "abcdefg";
    char str3[] = "hello world";
    const int res1 = strcmp(str1, str2); // 字符串不相等
    const int res2 = strcmp(str1, str3); // 字符串相等
    // 第一个是非0整数，第二个是0
    printf("%d %d", res1, res2);
}

```
由于非0数字都为真，所以我们只需要关注是不是0就行了。

关于返回的非0整数：strcmp() 实际上是比较每个字符的 ASCII 码是否相等，当比较到不相等的字符时，就会计算出两个字符的 ASCII 码差值并返回。所以返回的整数可能是负值。比如：
```c
strcmp("A", "B"); // 返回 -1
strcmp("B", "A"); // 返回 1
strcmp('B', 'A'); // 报错，不能使用单引号

'B' > 'A' // char 类型的本质就是 ASCII 码，所以可以直接比较，不需要 strcmp 这样的函数
```
我们也可以利用返回值的正负来实现按字母排序等功能。

#### strncmp() 函数
比较到第三个参数指定的个数就停止。
```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char str1[40] = "ABCDEFG";
    char str2[] = "ABCDGGG";
    const int res1 = strcmp(str1, str2);
    const int res2 = strncmp(str1, str2, 4); // 只比较前四个，所以相等
    printf("%d %d", res1, res2);
}

```

#### strcpy() 和 strncpy() 函数
将第二个参数字符串拷贝到第一个参数字符串，也要注意拷贝的字符串长度不能大于第一个参数的字符串长度。strcpy() 函数还有两个有用的特性：
1. strcpy() 的返回类型是 char *，该函数返回的是第1个参数的值，即一个字符的地址。
2. 第1个参数不必指向数组的开始。这个属性可用于拷贝数组的一部分。
```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char str1[40] = "ABCDEFGHIJK";
    char str2[] = "1234567";
    char str3[] = "abcdefg";
    strcpy(str1, str3); // 拷贝 str3 到 str1 中
    strncpy(str2, str3, 3); // str3 只拷贝前三个字符到 str2 中

    char str4[] = "aaaaaaa";
    char str5[] = "abc\0de";
    strncpy(str4, str5, 6); // str5 中含有空字符，拷贝到空字符则停止

    printf("%s\n%s\n%s", str1, str2, str4);
}

输出：
abcdefg
abc4567
abc
```
从输出的内容可以看出：
* 使用 strcpy 时，str1 被整个替换成了 str3，str3 的字符拷贝完后，str1 中多余的字符会替换成空字符。可以看做 str3 的内容赋值给了 str1。
* 使用 strncpy 时，str2 只替换了前三个，并且未替换的保留了。
* 使用 strncpy 时，str5 中含有空字符，则拷贝到空字符就停止了继续拷贝后面的字符（空字符和置顶的长度先遇到哪个就会终止拷贝），并且 str4 中拷贝到空字符之后的其它字符也被替换成了空字符。

#### 其它字符串函数
除了以上的字符串函数外，string.h 中还有很多其它字符串函数，如 strchr, strstr, strlen 等，具体使用方法可查看相关文档。

#### ctype.h 字符函数和字符串
ctype.h 中有很多处理字符的函数，我们不能直接用来处理字符串，但是可以通过遍历字符串等方式来处理字符串中的每个字符，从而达到处理字符串的目的。如 toupper() 函数可以将字符转为大写，要将字符串转为都转为大写就需要遍历字符串再调用 toupper() 函数：
```c
void ToUpper(char *str)
{
    while (*str)
    {
        // 将每个字符转换为大写字符
        *str = toupper(*str);
        str++;
    }
}
```

### 命令行参数
main() 函数的第二个参数可以接收命令行传参。
```c
#include <stdio.h>

// 第一个参数能知道命令行传了几个参数，第二个参数接收命令行具体参数
int main(int argc, char *argv[])
{
    int count;
    printf("The command line has %d arguments:\n", argc - 1);
    // 循环打印每个参数
    for (count = 1; count < argc; count++)
    {
        printf("%d: %s\n", count, argv[count]);
    }
}


假设我们将以上代码编译成了 test 程序，使用 ./test 运行次程序并传入参数：
./test --name Tirion

程序将会输出：
The command line has 2 arguments:
1: --name
2: Tirion
```
C 编译器允许 main() 没有参数或者有两个参数（一些实现允许 main() 有更多参数，属于对标准的扩展）。main() 有两个参数时，第1个参数是命令行中的字符串数量。过去，这个 int 类型的参数被称为 argc（表示参数计数 argument count）。系统用空格表示一个字符串的结束和下一个字符串的开始。该程序把命令行字符串存储在内存中，并把每个字符串的地址存储在指针数组中。而该数组的地址则被存储在 main() 的第2个参数中。按照惯例，这个指向指针的指针称为 argv（表示参数值 argument value）。许多环境都允许用双引号把多个单词括起来形成一个参数。如：`./test "--name Tirion"`。

### 字符串转数字
使用 atoi() 函数可以将字符串转为 int。也有 atof（转换为 double 类型）, atol（转换为 long 类型）等：
```c
#include <stdio.h>
#include <stdlib.h> // 引入 stdlib.h

int main(void)
{
    // 输出数字123
    printf("%d", atoi("123asdf"));
    // 输出数字0
    printf("%d", atoi("a123asdf"));
}
```

另外还有 strtol, strtod 等函数，拥有更强大的功能：
```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    char str[30] = "152945 This is test";
    char *ptr; // 将用来指向字符串中的某个字符
    long ret; // 存储字符串中转换出来的10进制数字

    /**
     * str 是待转换的字符串
     * &ptr 是指向指针的指针，指向一个指针，这个指针将指向字符串中的第一个非数字字符
     * 10 是原字符串中数字的进制，也可以是2，8，16等。
     * 当为8时，原字符串中的数字9也会中断；当为16时原字符串中的F也会当做数字被转换
    */
    ret = strtol(str, &ptr, 16);
    // ret 的值为：12321
    printf("数字（长整型）是：%ld\n", ret);
    // ptr 的值为：  This is test。T 前面有个空格。ptr 指向了字符串中的第一个非数字字符
    printf("字符串部分是：%s", ptr);
}
```

# 存储类别
从硬件方面来看，被存储的每个值都占用一定的物理内存，C 语言把这样的一块内存称为对象（object）。对象可以存储一个或多个值。一个对象可能并未存储实际的值，但是它在存储适当的值时一定具有相应的大小（面向对象编程中的对象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对象编程语言）。

### 作用域
C 语言的作用域和别的语言类似，主要注意一下几点：
##### 文件作用域
```c
#include <stdio.h>
int units = 0; /* 该变量具有文件作用域 */
void critic(void);
int main(void) { 
    ... 
}
void critic(void) { 
    ... 
}
```
units 变量具有文件作用域，从它定义之处起到文件末尾，任何地方都能访问，所以又叫全局变量。
另外 C 预处理是用包含的头文件内容替 换 #include 指令。所以，编译器把源代码文件和所有的头文件都看成是一个包含信息的单独文件。这个文件被称为翻译单元（translation unit）。描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。
所以，我们自己编写的头文件中声明了全局变量，被别的文件引用，那么这个全局变量也能被访问。我们在声明变量时也要注意变量名冲突。

##### 链接
C变量有3种链接属性：外部链接、内部链接或无链接。具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量。这意味着这些变量属于定义它们的块、函数或原型私有。具有文件作用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。一些程序员把“内部链接的文件作用域”简称为“文件作用域”，把“外部链接的文件作用域”简称为“全局作用域”或“程序作用域”。
我们可以通过 `static` 关键字指定变量是文件作用域还是全局作用域：
```c
int giants = 5; // 文件作用域，外部链接 
static int dodgers = 3; // 文件作用域，内部链接 
int main() { 
    ... 
}
```
当变量 dodgers 使用了 `static` 关键字后，这个变量就只能在此文件内中被访问。

##### 存储期
存储期描述了通过这些标识符访问的对象的生存期。C 对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。
* 如果对象具有静态存储期，那么它在程序的执行期间一直存在。文件作用域变量具有静态存储期。
* 线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。以关键字 `_Thread_local` 声明一个对象时，每个线程都获得该变量的私有备份。
* 块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。

### 存储类别
C 语言中有5种存储类别：自动、寄存器、静态块作用域、静态外部链接、静态内部链接，它们各自对应不同的存储期、作用域、链接。
![图 1](assets/1685966168152.png)  

##### 自动变量
属于自动存储类别的变量具有自动存储期、块作用域且无链接。默认情况下，声明在块或函数头中的任何变量都属于自动存储类别。
变量具有自动存储期意味着，程序在进入该变量声明所在的块时变量存在，程序在退出该块时变量消失。原来该变量占用的内存位置现在可做他用。
循环和 if 的条件语句也是一个块，循环体可以看做是其子块。条件语句中的变量也是自动存储类别变量。

##### 寄存器变量
变量通常存储在计算机内存中。如果幸运的话，寄存器变量存储在 CPU 的寄存器中，或者概括地说，存储在最快的可用内存中。与普通变量相比，访问和处理这些变量的速度更快。由于寄存器变量存储在寄存器而非内存中，所以无法获取寄存器变量的地址。绝大多数方面，寄存器变量和自动变量都一样。也就是说，它们都是块作用域、无链接和自动存储期。使用存储类别说明符 `register` 便可声明寄存器变量： 
```c
int main(void) {
    register int quick; // 尝试声明寄存器变量
}

void macho(register int n)
```
我们刚才说“如果幸运的话”，是因为声明变量为 `register` 类别与直接命令相比更像是一种请求。编译器必须根据寄存器或最快可用内存的数量衡量你的请求，或者直接忽略 你的请求，所以可能不会如你所愿。在这种情况下，寄存器变量就变成普通的自动变量。 即使是这样，仍然不能对该变量使用地址运算符。

##### 块作用域的静态变量
静态变量（static variable）听起来自相矛盾，像是一个不可变的变量。实际上，静态的意思是该变量在内存中原地不动，并不是说它的值不变。具有文件作用域的变量自动具有（也必须是）静态存储期。块作用域中也可以使用关键字 `static` 声明静态变量，当块执行完成时变量也不会销毁，而是依然存储在内存中。
```c
void trystat(void)
{
    int fade = 1;
    static int stay = 1; // 块中声明静态变量
    printf("fade = %d and stay = %d\n", fade++, stay++);
}
```

##### 外部链接的静态变量
外部链接的静态变量具有文件作用域、外部链接和静态存储期。该类别有时称为外部存储类别（external storage class），属于该类别的变量称为外部变量（external variable）。可以使用 `extern` 声明一个变量使用的是外部变量，如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须用 `extern` 在该文件中声明该变量。如下所示：
```c
int Errupt;       /* 外部定义的变量 */
double Up[100];   /* 外部定义的数组 */

extern char Coal; /* 如果 Coal 被定义在另一个文件，则必须这样声明 */

void next(void);

int main(void)
{
    extern int Errupt;  /* 可选的声明。只是声明变量使用的外部变量，不会再创建一个局部变量 */
    extern double Up[]; /* 可选的声明 */
    ...
}

void next(void) { ... }
```
外部变量具有静态存储期，因此在整个程序执行期间都存在，所以要谨慎声明，避免内存浪费。

1. 初始化外部变量：
与自动变量不同的是，如果未初始化外部变量，它们会被自动初始化为0。这一原则也适用于外部定义的数组元素。与自动变量的情况不同，只能使用**常量表达式**初始化文件作用域变量：
```c
#include <stdio.h>

int a = 10;
int b; // 没有初始值，则被初始化为0
int c = 1 + 1; // 可以，使用常量表达式初始化
// int d = a + 1; // 不行，外部变量必须使用常量表达式初始化，而 a 是变量

int main(void)
{
    printf("a=%d, b=%d", a, b);
}
```

2. 变量名称
C99和C11标准都要求编译器识别局部标识符的前63个字符和外部标识符的前31个字符。这修订了以前的标准，即编译器识别局部标识符前31个字符和外部标识符前6个字符。如果编译器较老，那么外部变量只能使用6个字符进行声明。

3. 定义和声明
```c
int tern = 1; /* tern 被定义 */ 
main() { 
    extern int tern; /* 使用在别处定义的 tern */
}
```
第2次声明只告诉编译器使用之前已创建的tern变量，所以这不是定义。第1次声明被称为定义式声明（defining declaration），第2次声明被称为引用式声明（referencing declaration）。关键字 extern 表明该声明不是定义，因为它指示编译器 去别处查询其定义。
```c
extern int tern; // 使用外部定义的 tern
int main(void) {}
```
编译器会假设 tern 实际的定义在该程序的别处，也许在别的文件中。**该声明并不会引起分配存储空间**。因此，不要用关键字 extern 创建外部定义，只用它来引用现有的外部定义。
外部变量只能初始化一次，且必须在定义该变量时进行。假设有下面的代码：
```c
// file_one.c 
char permis = 'N'; 
... 
// file_two.c 
extern char permis = 'Y'; /* 错误，外部变量只能初始化一次，不能再初始化 */
```
file_two 中 permis 使用外部变量，并再次初始化，会导致错误。

##### 内部链接的静态变量
该存储类别的变量具有静态存储期、文件作用域和内部链接。在所有函数外部（这点与外部变量相同），用存储类别说明符 static 定义的变量具有这种存储类别：
```c
static int svil = 1; // 静态变量，内部链接 
int main(void) {}
```
普通的外部变量可用于同一程序中任 意文件中的函数，但是内部链接的静态变量只能用于同一个文件中的函数。
```c
int traveler = 1; // 外部链接 
static int stayhome = 1; // 内部链接 
int main() { 
    extern int traveler; // 使用定义在别处的 traveler 
    extern int stayhome; // 使用定义在别处的 stayhome 
    ...
}
```
虽然在 main 函数中将 stayhome 使用 extern 关键字，但是 stayhome 依然只能在当前文件中访问，而 traveler 可以被其他文件访问。

##### 多文件
复杂的 C 程序通常由多个单独的源代码文件组成。有时，这些文件可能要共享一个外部变量。C 通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。也就是说，除了一个定义式声明外，其他声明都要使用 extern 关键字。而且，只有定义式声明才能初始化变量。
注意，如果外部变量定义在一个文件中，那么其他文件在使用该变量之前必须先声明它（用extern关键字）。

##### 存储类别说明符
C 语言有6个关 键字作为存储类别说明符：auto、register、static、extern、_Thread_local 和 typedef。

##### 存储类别和函数
函数也有存储类别，可以是外部函数（默认）或静态函数。C99新增了第3种类别——内联函数。外部函数可以被其他文件的函数访问，但是静态函数只能用于其定义所在的文件。
```c
double gamma(double); // 该函数默认为外部函数
static double beta(int, int); // 静态函数，仅此文件访问
extern double delta(double, int); // 使用 extern 声明外部函数
```
通常的做法是：用 extern 关键字声明**定义在其他文件中**的函数。这样做是为了表明当前文件中使用的函数被定义在别处。要声明一个可供其它文件访问的函数，什么关键字都不加即可。

**通常情况下，声明一个变量使用自动存储类别即可，即任何存储类别关键字都不加。只有当我们要明示存储类别的时候才添加对应的关键字加以说明。**