# 编译器
c 的编译器包括 GCC、Clang 等，编译 c 文件使用 cc （compile c）命令进行编译。安装了 GCC 和 Clang 的系统中，也可以使用 gcc 或 clang 命令进行编译。通常系统中带有 GCC 或 Clang 编译器，cc 命令是作为他们之一的别名使用。  
可以使用 `cc -v`, `gcc -v`, `clang -v` 来查看它们的版本。  
在 Windows 中需要安装 Cygwin 或 MinGW 来编译 c 代码，编译中生成的中间文件代码为 .obj，并且通常编译完成后不会删除。

# 预处理器
C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。
所有的预处理器命令都是以井号（#）开头。

\#define	定义宏
\#include	包含一个源代码文件
\#undef	取消已定义的宏
\#ifdef	如果宏已经定义，则返回真
\#ifndef	如果宏没有定义，则返回真
\#if	如果给定条件为真，则编译下面代码
\#else	#if 的替代方案
\#elif	如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码
\#endif	结束一个 #if……#else 条件编译块
\#error	当遇到标准错误时，输出错误消息
\#pragma	使用标准化方法，向编译器发布特殊的命令到编译器中

详情点击：[预处理器](https://www.runoob.com/cprogramming/c-preprocessors.html)

# main 函数
main 函数是 c 程序的入口，标准写法为：
```c
int main(void) {
    return 0;
}
```
这里要注意几点：
1. main 函数返回值为 int.
2. main 函数没有参数，所以参数为 void.
3. 由于返回值为 int 所以 return 0.
4. 但是编译器会自动给 main 函数加 return 0，所以可以省略写 return 0。注意只有 main 函数会这样，其它函数会 return void.

在某些教程中使用 void main 其实是不标准的，虽然大多数情况它能正常运行。

# 字面量后缀
在数字的后面可以添加字面量后缀来表示此数字的类型，如：100L、123U、12.3F 等。
```c
#include <stdio.h>
int main(void) {
    long n1 = 100L;
    unsigned n2 = 123U;
    float n3 = 12.3F;

    // 4294967295 是 unsigned int 的最大值
    int n3 = 4294967295; // 编译器会报错，值超过了 int 的最大值
    int n4 = 4294967295U; // 编译器通过，并且 n4 实际上是 unsigned int 类型，存储下了这个值
    int n5 = 1.2F; // 将一个指定为 float 的类型的数赋值给 int 类型，编译器会报错，并不会改变 n5 的类型为 float

    printf("%zd\n", sizeof(1.2)); // 输出8，浮点数默认为 double 类型
    printf("%zd\n", sizeof(1.2F)); // 输出4，指定了使用 float 类型来存储

    // 这里就比较特别了。
    // 由于使用了无符号整数 1U，此处会变成 有符号数 和 无符号数 的二元运算，导致的结果就是条件为正，但是实际上 -2 + 1U 的值是 -1
    // 所以要注意不要将无符号数和有符号数进行运算
    if (-2 + 1U > 0)
    {
        long a = 100L - 1;
        printf("%ld\n", a);
        printf("%d\n", -2 + 1U); // 输出-1
        printf("%d\n", -2 + 1U > 0); // 输出1
    }
}
```

# 整数溢出
可以把整数看作是汽车的里程表。当达到它能表示的最大值时，会重新从起始点开始。无符号和有符号整数它们主要的区别是，在超过最大值时，unsigned int 类型的变量从0开始；而 int 类型的变量则从−2147483648开始（即 int 类型的最小值，根据类型不同也会有所不同）。

其实就是补码最大值加1后的值，比如 char 类型占1字节即8位，无符号类型内存中的值就是 00000000 - 11111111 即 0 - 255，当255+1后为256，即11111111+1为100000000，但是 char 类型只有8位，所以是 00000000 即0。而有符号 char 则是 11111111 - 011111111 即 -128 - 127，当127+1即 01111111 + 1 为 11111111，所以成了-128。

**注：有符号类型的补码中首位为符号位，0表示正数1表示负数，00000000表示0，10000000不表示-0而是最小的负数，比如8位就是-128。所以负数要比正数多1。**

# 查看各种类型占用字节
以下是在 Mac 中的占用
```c
#include <stdio.h>

int main(void) {
    printf("%zd \n", sizeof(short)); // 2
    printf("%zd \n", sizeof(int));  // 4
    printf("%zd \n", sizeof(long)); // 8
    printf("%zd \n", sizeof(long long)); // 8
    printf("%zd \n", sizeof(float)); // 4
    printf("%zd \n", sizeof(double)); // 8
    printf("%zd \n", sizeof(char)); // 1
    printf("%zd \n", sizeof(_Bool)); // 1
    
    return 0;
}
```

# 转换说明
请求printf()函数打印数据的指令要与待打印数据的类型相匹配。例如，打印整数时 使用%d，打印字符时使用%c。这些符号被称为转换说明（conversion specification），它们指定了如何把数据转换成可显示的形式。  
**如果类型不匹配，那么输出的内容可能就会显得很莫名其妙。**  
具体的转换说明符参考：[转换说明表](https://www.cnblogs.com/ilegend/articles/2258701.html)

# 字符串
```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char c = 'A'; // 基本类型 char
    char s[40] = "这是个字符串"; // 派生类型 char 数组
    printf("%c\n", c); // 使用 %c 输出字符
    printf("%s\n", s); // 使用 %s 输出字符串
    printf("%d\n", c); // 会输出 A 对应的 ASCII 码
    printf("%d\n", s); // 会输出莫名的数值（所以类型必须要匹配）
    printf("%zd\n", strlen(s)); // 输出18
    return 0;
}
```
### 基本类型 char
基本类型 char 实际上是整数类型，存储的是一个字符的 ASCII 码，值用单引号，并且只能有一个在 ASCII 码中的字符。如中文不在 ASCII 码中，赋值给 char 会报错。

### 字符串 char 数组
当声明字符串时，应该使用 char 数组进行声明，并且使用双引号。由于字符串最后会有个 \0 结束符，所有实际上能存储的字符长度比声明时的长度少一位。**（但是我在 Mac 中测试，并未发现需要少输入一位，可能编译器不同？）**

### char 数组长度和中文
上面我们使用 `char s[40]` 定义了 s 的长度为40，由于1个 char 类型元素占用1字节，所以表示的是40字节。上面的内容为 `这是个字符串` 是6个中文字符，40个字节可以容纳6个中文字符，但是当我们改为 `char s[10]` 时，编译器就会发出警告，说我们的字符串太长了，是因为1个中文并不是只占用1个字节，中文不在 ASCII 编码中，属于 Unicode 编码，经测试1个中文字符占用的是3个字节，所以需要 `char s[18]` 才能正常编译。（上面 strlen(s) 输出18也能看出一个中文占用3个字节）
**Unicode 编码中的中文等字符存储在内存中也是二进制数字，一个汉字对应一个数值，3个字节足以表示各种语言的文字了。（计算机读取到 Unicode 编码内存位置时，应该会有某种机制告诉计算机这里存储的是 Unicode 编码，而不是普通的数字，读取后会使用 Unicode 编码进行解析成汉字输出。）**

# 常量
### 使用 #define 定义常量
\#define 又叫做宏，定义的常量又叫宏常量
```c
#include <stdio.h>
#define MAX 100 // 定义宏常量
#define ADD 1+2

int main(void) {
    int value1 = MAX * 2; // 使用宏常量
    int value2 = ADD * 3; // 替换后就会变成 1+2*3，结果不合预期
    return 0;
}
```
以上是使用 #define 定义了一个常量，在预处理时就会将使用的地方替换成定义的值，内存中并不会有一个叫 MAX 的常量。

### 使用 const 定义常量
const 定义的常量又叫不可变变量
```c
#include <stdio.h>

int main(void) {
    const int MAC = 100;
    const int ADD = 1 + 2;
    int value1 = MAC * 2;
    int value2 = ADD * 3; // 会是 3*3
    return 0;
}
```
具体区别可参考：[常量（const 和 #define 的区别）](https://blog.csdn.net/Mikchy/article/details/107072337)

# 运算
### 除法
c 语言中，整数除法返回的也是整数，这就导致整数相除产生的小数部分会被丢弃，所有在会使用到除法时，应该将变量定义为 float 或 double 等浮点数类型，而不应该定义为 int 这样的整数类型。
```c
#include <stdio.h>
int main(void)
{
    int a = 5;
    int b = 2;
    float c = 5;
    float d = 2;
    printf("%d\n", a / b); // 只会输出 2
    printf("%f\n", c / d); // 正常输出 2.500000
    printf("%f\n", a / d); // 正常输出 2.500000（整型与浮点型运算得到浮点型）
    printf("%d\n", a / d); // 这里用 %d 会导致编译器警告，并且输出的值错误
    return 0;
}
```
混合整数和浮点数计算的结果是浮点数。实际上，计算机不能真正用整数除以浮点数，编译器会把两个运算对象转换成相同的类型。本例中，在进行除法运算前，整数会被转换成浮点数。

# 运算符
除了常用的 + - * / % 之外，c 语言还提供了一些函数进行一些特定的运算操作。

### 求模运算
负数求模如何进行？如果第1个运算对象是负数，那么求模的结果为负数；如果第1个运算对象是正数，那么求模的结果也是正数：
11 / 5 得2，11 % 5 得1 
11 / -5 得-2，11 % -2 得1 
-11 / -5 得2，-11 % -5 得-1 
-11 / 5 得-2，-11 % 5 得-1

### sizeof 和 size_t
sizeof运算符以字节为单位返回运算对象的大小，运算对象可以是具体的数据对象（如，变量名）或类型。
**（在C中，1字节定义为char类型占用的空间大小。过去，1字节通常是8位，但是一些字符集可能使用更大的字节）。**
```c
#include <stdio.h>
int main(void)
{
    char str[10] = "你好";
    float f[10];
    printf("%zd\n", sizeof(str)); // 输出10
    printf("%zd\n", sizeof(char)); // 输出1
    printf("%zd\n", sizeof(int)); // 输出4
    printf("%zd\n", sizeof(f)); // 输出40，因为 float 占4个字节，10个 float 占40字节
    return 0;
}
```
C 语言规定，sizeof 返回 size_t 类型的值。而 size_t 并不是个新类型，而是某个标准类型的别名，使用 typedef 定义。C 头文件系统可以使用 typedef 把 size_t 作为 unsigned int 或unsigned long 的别名。这样，在使用 size_t 类型时，编译器会根据不同的系统替换标准类型。我们可以使用 %zd 转换说明来表示接受 size_t 类型。
（上面实例中如果使用 %d 接收 sizeof 返回值，编译器会提示应该使用 %lu 接收，即 unsigned long 类型，所以在 Mac 系统下 size_t 是 unsigned long 的别名。当然 Mac 中也可以使用 %lu 来接收 sizeof 返回值。）

# 类型转换
在使用不同类型进行运算时，C 语言会对类型进行转换后再运算，但是最好的做法是不要使用不同的类型进行运算。

### 类型转换规则
表达式中使用不同类型的转换规则：
1. 当类型转换出现在表达式时，无论是 unsigned 还是 signed 的 char 和 short 都会被 自动转换成 int，如有必要会被转换成 unsigned int。
2. 涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。
3. 类型的级别从高至低依次是 long double、double、float、unsigned long long、long long、unsigned long、long、unsigned int、int。例外的情况是，当 long 和 int 的大小相同时，unsigned int 比 long 的级别高。之所以 short 和 char 类型没有列出，是因为它们已经被升级到 int 或 unsigned int。
4. 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。
5. 当作为函数参数传递时，char 和 short 被转换成 int，float 被转换成 double。

**类型降级**——不同类型赋值时，被赋值类型比赋值类型更低级的转换规则：
1. 目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略。例如，如果目标类型是8位 unsigned char，待赋的值是原始值求模256。（260赋值给 unsigned char 会输出4）
2. 如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异。
3. 如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的。（通常的实现是直接截断小数部分。）

### 强制类型转换运算符
使用 (type)value 可以将 value 强制转换为 type 类型。
```c
#include <stdio.h>
int main(void)
{
    int a = 1.6 + 1.7;
    int b = (int)1.6 + (int)1.7;
    printf("%d\n", a); // 输出3
    printf("%d\n", b); // 输出2
    return 0;
}
```
本质上，两种类型转换都好不到哪里去，要考虑程序的具体情况再做取舍。

# 关系运算符
c 语言的关系运算符包括 `>, <, >=, <=, ==, !=` 6种，注意没有 JS 中 `===, !==` 这样的关系运算符，强类型语言都没有。
关系运算符可以使用 char 类型和 int 类型进行比较，因为 char 类型实际上也是 int 类型，会转换成 ASCII 中的数值。**但是字符串类型不能使用关系运算符进行比较，有专门的函数用于比较字符串，如 strcmp 函数。**

### 浮点数比较
虽然关系运算符也可用来比较浮点数，但是要注意：比较浮点数时，尽量只使用 < 和 >。因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等。例如，3乘以1/3的 积是1.0。如果用把1/3表示成小数点后面6位数字，乘积则是.999999，不等于1。使用 fabs() 函数（声明在math.h头文件中）可以方便地比较浮点数，该函数返回一个浮点值的绝对值（即，没有代数符号的值）。

### 什么是真
在 C 语言中，1表示真，0表示假。实际上非0的整数都是真，无论正负。而浮点数放到条件语句中编译器会给出警告，及时能作为真值继续运行。
```c
#include <stdio.h>
int main(void) {
    if (1) {} // 正常运行，为真
    if (0) {} // 正常运行，为假
    if (10) {} // 正常运行，为真
    if (-10) {} // 正常运行，为真
    if ('a') {} // 正常运行，为真
    if ('0') {} // 正常运行，为真
    if ('\0') {} // 正常运行，为假，char 类型的 \0 实际就是0
    if ("aaa") {} // 正常运行，为真
    if (1.2) {} // 编译器给出警告，为真
    // C 语言中没有 true 和 false
    if (true) {} // 编译器报错，中断运行
    if (false) {} // 编译器报错，中断运行
    int true = 1; // 我们甚至可以声明变量名为 true
}
```
**C 语言默认没有关键字 true 和 false，C99 提供了一个头文件 <stdbool.h> 定义了 bool 代表 _Bool，true 代表 1，false 代表 0。**
```c
#include <stdio.h>
#include <stdbool.h> // 布尔相关头文件
int main(void)
{
    bool a = true;
    if (a)
    {
        printf("%d\n", 'a' > 3);
    }
}
```

# 函数
C 语言中，函数通常使用先声明再定义的写法。
```c
#include <stdio.h>
// 函数声明（函数原型）：函数的返回类型，名称，参数个数及类型 
int getN(int);
// int getN(int n); 参数可以取名可以不取名，个人感觉不取名更简洁

int main(void)
{
    // 函数调用
    int n = getN(10);
    printf("%d", n);
}

// 函数定义：对函数的实现
int getN(int n) {
    return n;
}
```
C 语言中，函数需要先声明再调用。
1. 上面代码中如果删除函数声明，但是保留函数定义，编译器会给出警告。编译器在运行到 getN(10) 时，此时发现并没有 getN 函数，会产生一个函数的隐式声明，也就是编译器会帮我们声明 getN 函数，由于我们后面实现了 getN，所以程序没有出错。但是隐式声明是有风险的，程序员应该避免这样的错误。
2. 如果将函数声明和函数定义都删除，则会直接报错。虽然编译器会帮我们生成隐式声明，但是函数没有实现，所以无法调用。
3. 将 getN 函数定义放在 main 函数之前，此时不写函数声明也没问题，但是这不符合规范，通常是将 main 函数放在最前面，函数定义可能放在 main 后面或其它文件中。

### 任意多个参数函数
一些函数接受（如，printf() 和 scanf()）许多参数。例如对于 printf()，第1个参数是字符串，但是其余参数的类型和数量都不固定。对于这种情况，ANSI C 允许使用部分原型。例如，对于 printf() 可以使用下面的原型：
```c
int printf(const char *, ...);
```
这种原型表明，第1个参数是一个字符串，可能还有其他未指定的参数。C 库通过 stdarg.h 头文件提供了一个定义这类（形参数量不固定的）函数的标准方法。

### 尾递归
最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。这种形式的递归被称为尾递归（tail recursion），因为递归调用在函数的末尾。尾递归是最简单的递归形式，因为它相当于循环。

### 指数增长的递归
```c
unsigned long Fibonacci(unsigned n)
{
    if (n > 2)
        return Fibonacci(n - 1) + Fibonacci(n - 2);
    else
        return 1;
}
```
上面是个计算斐波那契数列的递归，每次递归都会调用两次自身，所以创建的变量每次递归都是上次的两倍，这就是指数级增长的递归。所以在编写递归程序里要避免在递归中多次调用自身。

# 字符处理
### getchar 和 putchar
getchar 和 putchar 是 stdio.h 中定义的预处理宏，用于专门读取和打印字符，因为只针对字符，所以比通用的 scanf 和 printf 更高效。
```c
#include <stdio.h>

int main(void)
{
    char ch;
    ch = getchar(); // 读取一个字符
    
    while (ch != '\n') { // 当前读取的字符不是换行符则继续循环（控制台输入完字符后敲回车，实际上还会在末尾输入个 \n）
        if (ch == ' ') {
            putchar(ch); // 空格则正常打印
        } else {
            putchar(ch + 1); // 非空格+1后再打印，如字符 a 会+1后变成字符 b 打印（ASCII 码的下个字符）
        }

        ch = getchar(); // 读取下一个字符
    }

    putchar(ch); // 打印最后一个 \n
    printf("%c", ch);
}
```
以上代码运行后，我们在控制台输入一串字符后，字符会进入缓冲区，程序会从缓冲区一个一个的读取字符进行操作。
**注意：一个中文占用3个字符，如果我们只读取一个字符，存到 char 变量中，然后输出，则会是乱码。而如果使用循环不断读取并输出，则3个字符会作为一个中文输出。**
下面我们使用 scanf 和 printf 来验证：
```c
#include <stdio.h>
int main(void) {
    char c;
    int i = 0; // 循环计数器
    scanf("%c", &c); // 这里我们输入一个中文
    while (c != '\n') { // 循环读取控制台的输入
        i++;
        printf("%c", c); // 打印每次的输入
        scanf("%c", &c); // 读取下一个输入
    }
    printf("%d", i); // 输入一个中文，会输出3，说明一个中文循环了3次才完整输出
}
```

### ctype.h
ctype.h 包含一系列用于判断字符类别的函数。如： isalpha() 判断传入的字符是否是字母；ispunct() 判断是否是标点符号等。
具体查看：[ctype.h 标准库](https://www.runoob.com/cprogramming/c-standard-library-ctype-h.html)

# goto 语句
`goto` 语句类似 JS 中的 `break label` 语句。但是 `break label` 只能用于循环中，`goto` 语句却可以用在任何地方。所以 `goto` 语句使用更灵活，但是也更易导致问题，需要谨慎使用，最好只用在 `break label` 这样的地方，用于跳出多层嵌套循环。

示例1：
```c
// 使用 goto 语句来实现 if
if (size > 12)
    goto a;
goto b;
a:
cost = cost * 1.05;
flag = 2;
b:
bill = cost * flag;
```
```c
// 使用 if 明显更易理解
if (size > 12)
{
    cost = cost * 1.05;
    flag = 2;
}
bill = cost * flag;
```
示例2：
```c
if (ibex > 14)
    goto a;
sheds = 2;
goto b;
a:
sheds = 3;
b:
help = 2 * sheds;
```
```c
// 使用 if else 明显更好
if (ibex > 14)
    sheds = 3;
else
    sheds = 2;
help = 2 * sheds;
```
**下面是可接受的用法：**
```c
while (funct > 0)
{
    for (i = 1; i <= 100; i++)
    {
        for (j = 1; j <= 50; j++)
        {
            其他语句 
            if (问题) 
                goto help; // 嵌套循环中跳转到 help 位置
            其他语句
        }
        其他语句
    }
    其他语句
}
其他语句 
help: 语句 // 会直接跳转到这里继续执行
```

# 字符输入输出和输入验证
C 语言 stdio.h 标准库中包含一些标准的 IO 函数，它们可以在不同的系统中运行，如 Windows, Linux, Mac OS。但是一些特殊的硬件等也会实现并提供自身的 IO 函数，可能需要通过引入其头文件来使用。

### 缓冲区
无缓冲输入：当使用 scanf, getchar 这样的函数时，如果用户在控制台每输入一个字符就被程序接收并立即执行，比如我们要将输入的内容进行输入，就可能出现控制台显示为：HHeelloo。这就是无缓冲输入的表现。
缓冲输入：用户输入的字符被收集并存储在一个被称为缓冲区（buffer）的临时存储区，按下 Enter 键后，程序才可使用用户输入的字符。
![图 1](assets/1679282142322.png)  

为什么要有缓冲区？首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下 Enter 键时， 传输的是正确的输入。

虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中， 你希望按下一个键就执行相应的指令。因此，缓冲输入和无缓冲输入都有用武之地。

缓冲分为两类：完全缓冲 I/O 和行缓冲 I/O。完全缓冲输入指的是当缓冲区被填满时 才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是512字节和4096字节。行缓冲 I/O 指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下 Enter 键后才刷新缓冲区。

### 文件结尾
读取文件的时候如何判断文件达到了末尾？
第一种方法是使用 ctrl+Z 字符来作为结尾标记，当读到 ctrl+Z 即 `^Z` 时便到了末尾，但是这种方法也说明文件中不能人为输入 `^Z`，否则程序读到这里就终止读取了。
第二种方法是使用存储文件大小的信息。如果文件有3000字节，程序在读到3000字节时便达到文件的末尾。现在大部分操作系统都使用这种方式，这种方式也就可以在文件中人为写入 `^Z` 字符。
无论操作系统实际使用何种方法检测文件结尾，在C语言中，用 getchar 或 scanf 读取文件检测到文件结尾时将返回一个特殊的值，即 EOF（end of file 的缩写）。通常，EOF 定义在 stdio.h 文件中：
```c
#define EOF (-1)
```
为什么是-1？因为如果是正整数则可能是某个字符的 ASCII 编码，而-1不是 ASCII 码。可能某些系统返回的不是-1，而是-2或其它值，所以我们使用 EOF 常量名来判断就不会出错。
```c
while ((ch = getchar()) != EOF) // 使用 EOF 而不是-1
```

### 重定向输入
在运行一个 C 语言编译后的程序的时候，假设这个程序像之前的功能一样读取键盘输入并输出。我们在控制台使用 `./test` 来执行这个编译后的程序时，可以使用重定向来讲输入重定向到一个文件，而不是通过键盘输入。只需要像这样
`./test < ../test.c`
就能将源代码 test.c 文件作为输入，控制台中就会打印出 test.c 的内容。

### 重定向输出
使用 > 可以将输出进行重定向，从而写入某个文件而不是通过显示器作为输出设备。
`./test > ./test.txt`
这样就能将控制台中的输入写入 test.txt 文件中了（没有 test.txt 或创建文件，有则会覆盖内容）。

### 组合重定向
将两个符号组合使用就能实现复制功能：
`./test < ../test.c > ./test.c`
（测试时发现输出文件末尾多了两个乱码字符，不知道是为什么？）
UNIX、Linux 或 Windows/DOS 还有 `>>` 运算符，该运算符可以把数据添加到现有文件的末尾，而 `|` 运算符能把一个文件的输出连接到另一个文件的输入。

### 输入流和数字
使用 scanf 读取控制台的输入，C 语言会将控制台的输入内容作为字节流来处理。
当我们在控制台输入42，scanf 使用不同的转换说明会产生怎样的效果呢？
如果在 scanf() 函数中使用 %c 转换说明，它只会读取字符4并将其存储在 char 类型的变量中。如果使用 %s 转换说明，它会读取字符4和字符2这两个字符，并将其存储在字符数组中。如果使用 %d 转换说明，scanf() 同样会读取两个字符，但是随后会计算出它们对应的整数值：4×10+2，即42，然后将表示该整数的二进制数存储在 int 类型的变量中。如果使用 %f 转换说明，scanf() 也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示法表示该值，并将结果存储在 float 类型的变量中。
也就是 scanf 在使用不同的转换说明时，内部会针对读取到的字节流用不同的算法进行处理后赋值给变量。

# 编写头文件
我们可以使用 .h 为后缀的文件来编写自己的头文件，如 name.h 。使用头文件则是使用 `#include "name.h"` 双引号的形式引入自己的头文件。

# &运算符
当使用函数时，如果不使用 return 返回的值来改变已有的变量，则必须通过地址才能去修改已有变量的值。
一元 `&` 运算符给出变量的存储地址。如果 `pooh` 是变量名，那么 `&pooh` 是变量的地址。可以把地址看作是变量在内存中的位置。
```c
#include <stdio.h>

int main(void)
{
    int pooh = 20;
    printf("%d\n%p", pooh, &pooh);
    return 0;
}
```
以上代码输出了变量 pooh 的值和内存地址。`%p` 是输出地址的转换说明。

# 指针
什么是指针？从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如 char 类型变量的值是字符，int 类型变量的值是整数，指针变量的值是地址。

### 间接运算符（解引用运算符）
间接运算符的作用是从地址中解出它的值。
```c
// 将 c 的地址赋值给 a
a = &b;
// 将 a 地址解析出来赋值给 c
c = *a;

// 上面两句的作用等同于下面一句
c = b;
```

### 声明指针
声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道存储在指定地址上的数据类型。
```c
int * pi; // pi 是指向 int 类型变量的指针 
// * 前后都可以不带空格
char *pc; // pc 是指向 char 类型变量的指针 
float * pf, * pg; // pf、pg 都是指向 float 类型变量的指针
```
上面的 `int *pc` 可以解释为：`*pc` 是 char 类型，那么 `pc` 就不是 char 类型，而是指向 char 类型的指针。pc 的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是指针不是整数类型，比如我们不能将两个指针相乘。所以指针是一个新的类型。

下面是使用指针交换两个变量值的示例：
```c
#include <stdio.h>
void interchange(int *u, int *v);

int main(void)
{
    int x = 5, y = 10;
    printf("Originally x = %d and y = %d.\n", x, y);
    interChange(&x, &y); // 把地址发送给函数
    printf("Now x = %d and y = %d.\n", x, y);
    return 0;
}

void interChange(int *u, int *v)
{
    int temp;
    temp = *u; // temp 获得 u 所指向对象的值
    *u = *v; // 将 v 地址的值赋值给 u 地址的值
    *v = temp;
}
```
**注意：**
1. 在调用 `interChange(&x, &y)` 传入 x 和 y 的地址，这个地址是复制给函数声明 `void interChange(int *u, int *v)` 中的变量 u 和 v，而不是 *u 和 *v。变量 u 接收了 x 的地址，*u 将地址所指的内存数据解析成 int 值。
2. 当修改 *u 的值时，如 `*u = 100` 表示将 u 这个地址的值改为100。如果使用 `u = 100` 就成了将 u 指向的内存地址改为指向100这个内存地址，就不对了。（可以理解为：u 指向 x 的地址，*u 则等同于 x，我们对 *u 进行赋值，则是对变量 x 进行赋值。）
3. 当然，我们在某些情况下也可能对内存地址进行赋值，比如 `u = v`，那么此时 u 和 v 都指向了相同的内存地址，我们赋值 `*u = 100`后则 *v 也成了100，main 函数中的 y 也成了100。

# 数组
需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可以用。
```c
int main(void) {
    float candy[365]; // 内含365个 float 类型元素的数组
    char code[12]; // 内含12个 char 类型元素的数组
    int states[50]; // 内含50个 int 类型元素的数组
}
```

### 初始化数组
C 语言中使用花括号 `{ }` 来初始化数组，而不是中括号 `[ ]`。
```c
int main(void) {
    int powers[8] = {1, 2, 4, 6, 8, 16, 32, 64};

    // 使用 const 初始化数组后，数组就不能被修改了
    const int arr[10] = {1, 2, 3}
    // arr[5] = 5; // 修改 arr 会报错
}
```
上面 arr 数组在初始化时只初始化了前三位，由于类型是 int，那么后7位都默认是0。如果类型是 char，那么后7位就默认是空字符。

如果声明了数组，但是未初始化，那么数组里面的值就会很奇怪，可能是分配内存地址之前的值，属于垃圾值。但是只要初始化后，就会对此段内存地址按照声明的类型赋上默认值。
```c
#include <stdio.h>
int main(void)
{
    int arr[10]; // 未初始化，遍历输出的值是垃圾值
    // int arr[10] = {}; // 初始化了，所有值为0

    for (int i = 0; i < 10; i++) {
        printf("%d\n", arr[i]);
    }
};
```

如果不指定数组长度，那么编译器就会根据初始化值分配数组长度。
```c
#include <stdio.h>
int main(void)
{
    // 会根据初始值指定长度为10
    const int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31};
    // 因为下面要和 sizeof 的值进行比较，所以声明为 unsigned long 类型才相同
    unsigned long index;
    for (index = 0; index < sizeof days / sizeof days[0]; index++) {
        printf("Month %2lu has %d days.\n", index + 1, days[index]);
    }
    return 0;
}
```
**上面代码中通过 sizeof 计算出了数组的长度。sizeof 运算符给出它的运算对象的大小（以字节为单位）。所以 `sizeof days` 是整个数组的大小（以字节为单位），`sizeof days[0]` 是数组中一个元素的大小（以字节为单位）。整个数组的大小除以单个元素的大小就是数组元素的个数。**

### 指定初始化器（C99）
置顶初始化器是 C99 新增的语法糖，可以初始化数组中后面的元素，而不用写前面的。
```c
int arr[6] = {0, 0, 0, 0, 0, 212}; // 传统的语法
int arr[6] = {[5] = 212}; // 把 arr[5] 初始化为212

int arr[6] = {};
arr[5] = 212; // 这样也可以

/*
* 索引2和3值为0
* 30会赋值给索引5
* 29会修改索引1，即索引1的28会改为29
*/
int days[12] = { 31, 28, [4] = 31, 30, 31, [1] = 29 };
```

**注意：C 不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋值。只能使用循环一个个赋值。**
```c
#include <stdio.h>
#define SIZE 5
int main(void)
{
    int oxen[SIZE] = {5, 3, 2, 8}; // 初始化没问题
    int yaks[SIZE];
    // 不允许将一个数组赋值给另一个数组
    yaks = oxen;
    // 数组下标越界，yaks 长度是5，而 yarks[5] 是给第6个元素赋值
    yaks[SIZE] = oxen[SIZE];
    // 不起作用
    yaks = {5, 3, 2, 8};
}
```

### 数组边界
C 语言中数组是有长度的，对数组外的索引进行取值/赋值操作叫做数组越界操作。当数组越界时编译器不会检查下标使用是否得当（有些编译器会警告但是继续执行），所以一定要小心数组越界问题。在C标准中，使用越界下标的结果是未定义的，不同的编译器可能给出不同的结果。
如果给越界的下标赋值，越界的下标可能指向的是另一个变量的内存地址，这时就会修改到另一个变量的值。所以越界操作是非常危险的。

### 变长数组
C99 之前创建数组，中括号中只能使用整型常量，不能使用变量。sizeof 表达式被视为整型常量。const 声明的变量也不行。
C99 之后可以使用变量声明数组的长度，这种数组称为变长数组。
但是在声明变长数组时不能进行初始化。若初始化，编译器会报错。
```c
int main(void)
{
    int n = 5;
    int m = 8;
    const int o = 7;
    float a1[5];               // 可以
    float a2[5 * 2 + 1];       // 可以
    float a3[sizeof(int) + 1]; // 可以
    float a4[-4];              // 不可以，数组大小必须大于0
    float a5[0];               // 不可以，数组大小必须大于0
    float a6[2.5];             // 不可以，数组大小必须是整数
    float a7[(int)2.5];        // 可以，已被强制转换为整型常量
    float a8[n];               // 变长数组，C99之前不允许
    float a9[m];               // 变长数组，C99之前不允许
    float a10[o];               // 变长数组，const 声明的也是变量
}
```

### 多维数组
声明多维数组使用多个中括号即可。
```c
float rain[5][12]; // 内含5个数组元素的数组，每个数组元素内含12个float类型的元素
```
在计算机内部，这样的数组是按顺序存储的，从第1个内含12个元素的数组开始，然后是第2个内含12个元素的数组，以此类推。
以下是对多维数组的初始化：
```c
const float rain[5][12] = {
    {4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6}, 
    {8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.3}, 
    {9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.1, 8.4}, 
    {7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 6.2}, 
    {7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 5.2}
};
```
初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数 值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。